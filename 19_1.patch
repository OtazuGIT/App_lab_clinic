diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1,38 +1,38 @@
 # main_window.py
 import copy
 import datetime
 import json
 import os
 import re
 import unicodedata
 from collections import OrderedDict
 from PyQt5.QtWidgets import (QMainWindow, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
                              QStackedWidget, QFormLayout, QScrollArea, QGroupBox, QComboBox,
                              QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, QCheckBox,
                              QDateEdit, QRadioButton, QButtonGroup, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem,
-                             QSpinBox)
+                             QSpinBox, QInputDialog)
 from PyQt5.QtCore import QDate, QDateTime, Qt, QTimer
 from fpdf import FPDF  # Asegúrese de tener fpdf instalado (pip install fpdf)
 
 LAB_TITLE = "Laboratorio P.S. Iñapari - 002789"
 
 REGISTRY_ABBREVIATIONS = {
     "hematocrito": "Hto",
     "hematocrito (hto)": "Hto",
     "hemoglobina": "Hb",
     "hemoglobina (hb)": "Hb",
     "hemoglobina - hematocrito": "Hb/Hto",
     "hemoglobina hematocrito": "Hb/Hto",
     "leucocitos": "Leu",
     "leucocitos totales": "Leu",
     "recuento de leucocitos": "Leu",
     "recuento de hematies": "RBC",
     "recuento de hematies (rbc)": "RBC",
     "hematies": "RBC",
     "plaquetas": "Plaq",
     "recuento de plaquetas": "Plaq",
     "plaquetas totales": "Plaq",
     "vcm": "VCM",
     "hcm": "HCM",
     "chcm": "CHCM",
     "rdw": "RDW",
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1246,75 +1246,83 @@ class MainWindow(QMainWindow):
         self.input_doc_number = QLineEdit()
         btn_search = QPushButton("Buscar"); btn_search.setFixedWidth(60)
         btn_search.clicked.connect(self.autofill_patient)
         doc_hlayout = QHBoxLayout()
         doc_hlayout.addWidget(self.input_doc_type); doc_hlayout.addWidget(self.input_doc_number); doc_hlayout.addWidget(btn_search)
         form_layout.addRow("Documento:", doc_hlayout)
         self.input_first_name = QLineEdit(); form_layout.addRow("Nombre:", self.input_first_name)
         self.input_last_name = QLineEdit(); form_layout.addRow("Apellidos:", self.input_last_name)
         # Fecha de nacimiento y edad calculada automáticamente (editable)
         self.input_birth_date = QDateEdit()
         self.input_birth_date.setDisplayFormat("dd-MM-yyyy")
         self.input_birth_date.setCalendarPopup(True)
         self.input_birth_date.setDate(QDate.currentDate())
         self.input_birth_date.dateChanged.connect(self.update_age_from_birth_date)
         form_layout.addRow("F. Nacimiento:", self.input_birth_date)
         self.input_age = QLineEdit()
         self.input_age.setPlaceholderText("Edad estimada")
         form_layout.addRow("Edad:", self.input_age)
         # Sexo como botones exclusivos
         self.sex_male_radio = QRadioButton("Masculino")
         self.sex_female_radio = QRadioButton("Femenino")
         self.sex_group = QButtonGroup(self.page_registro)
         self.sex_group.addButton(self.sex_male_radio)
         self.sex_group.addButton(self.sex_female_radio)
         self.sex_male_radio.setChecked(True)
+        self.sex_male_radio.toggled.connect(self.update_pregnancy_visibility)
+        self.sex_female_radio.toggled.connect(self.update_pregnancy_visibility)
         sex_layout = QHBoxLayout()
         sex_layout.addWidget(self.sex_male_radio)
         sex_layout.addWidget(self.sex_female_radio)
         sex_layout.addStretch()
         form_layout.addRow("Sexo:", sex_layout)
+        self.insurance_combo = QComboBox()
+        self.insurance_combo.addItems(["SIS", "Particular"])
+        form_layout.addRow("Tipo de seguro:", self.insurance_combo)
         self.pregnancy_checkbox = QCheckBox("Paciente gestante")
         self.pregnancy_checkbox.stateChanged.connect(self.on_pregnancy_toggle)
         self.gestational_weeks_spin = QSpinBox()
         self.gestational_weeks_spin.setRange(0, 45)
         self.gestational_weeks_spin.setSuffix(" sem")
         self.gestational_weeks_spin.setEnabled(False)
         self.expected_delivery_date = QDateEdit(QDate.currentDate())
         self.expected_delivery_date.setDisplayFormat("dd-MM-yyyy")
         self.expected_delivery_date.setCalendarPopup(True)
         self.expected_delivery_date.setEnabled(False)
-        pregnancy_layout = QHBoxLayout()
+        self.pregnancy_container = QWidget()
+        pregnancy_layout = QHBoxLayout(self.pregnancy_container)
+        pregnancy_layout.setContentsMargins(0, 0, 0, 0)
         pregnancy_layout.addWidget(self.pregnancy_checkbox)
         pregnancy_layout.addSpacing(8)
         pregnancy_layout.addWidget(QLabel("Edad gestacional:"))
         pregnancy_layout.addWidget(self.gestational_weeks_spin)
         pregnancy_layout.addSpacing(8)
         pregnancy_layout.addWidget(QLabel("FPP:"))
         pregnancy_layout.addWidget(self.expected_delivery_date)
         pregnancy_layout.addStretch()
-        form_layout.addRow("Gestación:", pregnancy_layout)
+        form_layout.addRow("Gestación:", self.pregnancy_container)
+        self.update_pregnancy_visibility()
         # Procedencia con opción rápida P.S Iñapari u otros
         self.origin_combo = QComboBox()
         self.origin_combo.addItems(["P.S Iñapari", "Otros"])
         self.origin_combo.currentIndexChanged.connect(self.on_origin_changed)
         self.input_origin_other = QLineEdit()
         self.input_origin_other.setPlaceholderText("Especifique procedencia")
         self.input_origin_other.setEnabled(False)
         origin_layout = QHBoxLayout()
         origin_layout.addWidget(self.origin_combo)
         origin_layout.addWidget(self.input_origin_other)
         form_layout.addRow("Procedencia:", origin_layout)
         self.input_hcl = QLineEdit(); form_layout.addRow("HCL:", self.input_hcl)
         self.input_height = QLineEdit(); self.input_height.setPlaceholderText("cm")
         form_layout.addRow("Talla (cm):", self.input_height)
         self.input_weight = QLineEdit(); self.input_weight.setPlaceholderText("kg")
         form_layout.addRow("Peso (kg):", self.input_weight)
         self.input_blood_pressure = QLineEdit(); self.input_blood_pressure.setPlaceholderText("ej. 120/80")
         form_layout.addRow("Presión Art.:", self.input_blood_pressure)
         self.input_diagnosis = QLineEdit(); self.input_diagnosis.setPlaceholderText("Ej. Síndrome febril")
         form_layout.addRow("Diagnóstico presuntivo:", self.input_diagnosis)
         self.input_observations = QLineEdit()
         self.input_observations.setPlaceholderText("Observaciones (laboratorio)")
         self.input_observations.setText("N/A")
         obs_layout = QHBoxLayout()
         obs_layout.addWidget(self.input_observations)
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1414,145 +1422,162 @@ class MainWindow(QMainWindow):
             self.input_age.setText(str(years))
         else:
             self.input_age.clear()
     def on_origin_changed(self, index):
         use_other = self.origin_combo.currentText() == "Otros"
         self.input_origin_other.setEnabled(use_other)
         if not use_other:
             self.input_origin_other.clear()
 
     def on_sample_today_toggle(self, state):
         use_today = state == Qt.Checked
         if hasattr(self, 'sample_date_edit'):
             self.sample_date_edit.setEnabled(not use_today)
             if use_today:
                 self.sample_date_edit.setDate(QDate.currentDate())
     def on_pregnancy_toggle(self, state):
         is_checked = state == Qt.Checked
         if hasattr(self, 'gestational_weeks_spin'):
             self.gestational_weeks_spin.setEnabled(is_checked)
             if not is_checked:
                 self.gestational_weeks_spin.setValue(0)
         if hasattr(self, 'expected_delivery_date'):
             self.expected_delivery_date.setEnabled(is_checked)
             if not is_checked:
                 self.expected_delivery_date.setDate(QDate.currentDate())
+
+    def update_pregnancy_visibility(self):
+        is_female = self.sex_female_radio.isChecked() if hasattr(self, 'sex_female_radio') else False
+        if hasattr(self, 'pregnancy_container'):
+            self.pregnancy_container.setVisible(is_female)
+        if hasattr(self, 'pregnancy_checkbox'):
+            self.pregnancy_checkbox.setEnabled(is_female)
+            if not is_female:
+                self.pregnancy_checkbox.blockSignals(True)
+                self.pregnancy_checkbox.setChecked(False)
+                self.pregnancy_checkbox.blockSignals(False)
+                self.on_pregnancy_toggle(Qt.Unchecked)
+            else:
+                state = Qt.Checked if self.pregnancy_checkbox.isChecked() else Qt.Unchecked
+                self.on_pregnancy_toggle(state)
     def get_current_origin(self):
         if self.origin_combo.currentText() == "Otros":
             other = self.input_origin_other.text().strip()
             return other if other else "Otros"
         return "P.S Iñapari"
     def set_origin_value(self, value):
         if value and value.strip().lower() not in ("p.s iñapari", "ps iñapari", "p.s. iñapari"):
             self.origin_combo.setCurrentIndex(1)
             self.input_origin_other.setEnabled(True)
             self.input_origin_other.setText(value)
         else:
             self.origin_combo.setCurrentIndex(0)
             self.input_origin_other.setEnabled(False)
             self.input_origin_other.clear()
     def _format_number(self, value):
         if value in (None, ""):
             return ""
         if isinstance(value, float):
             if value.is_integer():
                 return str(int(value))
             return f"{value:.2f}".rstrip('0').rstrip('.')
         return str(value)
     def autofill_patient(self):
         doc_type = self.input_doc_type.currentText()
         doc_number = self.input_doc_number.text().strip()
         if doc_number == "":
             return
         patient = self.labdb.find_patient(doc_type, doc_number)
         if patient:
             # Rellenar campos con datos existentes
             (_, _, _, first_name, last_name, birth_date, sex, origin, hcl,
              height, weight, blood_pressure, is_pregnant, gest_age, expected_delivery) = patient
             self.input_first_name.setText((first_name or "").upper()); self.input_last_name.setText((last_name or "").upper())
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     self.input_birth_date.setDate(bd)
                 else:
                     self.input_birth_date.setDate(QDate.currentDate())
                     self.input_age.clear()
             else:
                 self.input_birth_date.setDate(QDate.currentDate())
                 self.input_age.clear()
             if sex == "Femenino":
                 self.sex_female_radio.setChecked(True)
             else:
                 self.sex_male_radio.setChecked(True)
+            self.update_pregnancy_visibility()
             self.set_origin_value(origin or "")
             self.input_hcl.setText(hcl or "")
             self.input_height.setText(self._format_number(height))
             self.input_weight.setText(self._format_number(weight))
             self.input_blood_pressure.setText(blood_pressure or "")
             preg_flag = bool(is_pregnant) if is_pregnant not in (None, "") else False
             self.pregnancy_checkbox.blockSignals(True)
             self.pregnancy_checkbox.setChecked(preg_flag)
             self.pregnancy_checkbox.blockSignals(False)
             self.on_pregnancy_toggle(Qt.Checked if preg_flag else Qt.Unchecked)
             if preg_flag:
                 if gest_age is not None:
                     try:
                         self.gestational_weeks_spin.setValue(int(gest_age))
                     except (TypeError, ValueError):
                         self.gestational_weeks_spin.setValue(0)
                 if expected_delivery:
                     edd = QDate.fromString(expected_delivery, "yyyy-MM-dd")
                     if edd.isValid():
                         self.expected_delivery_date.setDate(edd)
                     else:
                         self.expected_delivery_date.setDate(QDate.currentDate())
             else:
                 self.gestational_weeks_spin.setValue(0)
                 self.expected_delivery_date.setDate(QDate.currentDate())
             QMessageBox.information(self, "Paciente encontrado", "Datos del paciente cargados.")
     def register_patient(self, btn_to_results):
         doc_type = self.input_doc_type.currentText()
         doc_number = self.input_doc_number.text().strip()
         if doc_number == "" or self.input_first_name.text().strip() == "" or self.input_last_name.text().strip() == "":
             QMessageBox.warning(self, "Datos incompletos", "Ingrese al menos Documento, Nombre y Apellidos.")
             return
         # Validar formato de documento
         if doc_type == "DNI":
             if len(doc_number) != 8 or not doc_number.isdigit():
                 QMessageBox.warning(self, "Documento inválido", "El DNI debe tener 8 dígitos.")
                 return
         else:
             if len(doc_number) > 20:
                 QMessageBox.warning(self, "Documento inválido", f"El {doc_type} no debe exceder 20 caracteres.")
                 return
         # Obtener datos del formulario
         first_name = self.input_first_name.text().strip().upper()
         last_name = self.input_last_name.text().strip().upper()
         self.input_first_name.setText(first_name)
         self.input_last_name.setText(last_name)
         birth_date = self.input_birth_date.date().toString("yyyy-MM-dd")
         sex = "Femenino" if self.sex_female_radio.isChecked() else "Masculino"
+        insurance_type = self.insurance_combo.currentText() if hasattr(self, 'insurance_combo') else "SIS"
         origin = self.get_current_origin()
         if self.origin_combo.currentText() == "Otros" and (not self.input_origin_other.text().strip()):
             QMessageBox.warning(self, "Procedencia requerida", "Indique la procedencia del paciente cuando seleccione 'Otros'.")
             return
         hcl = self.input_hcl.text().strip()
         height = self.input_height.text().strip()
         weight = self.input_weight.text().strip()
         bp = self.input_blood_pressure.text().strip()
         diagnosis = self.input_diagnosis.text().strip()
         observations = self.input_observations.text().strip() or "N/A"
         requested_by_text = self.input_requested_by.currentText().strip() if self.input_requested_by.count() else ""
         if requested_by_text == "":
             requested_by_text = "N/A"
         if diagnosis == "":
             diagnosis = "N/A"
         age_text = self.input_age.text().strip()
         if age_text:
             try:
                 age_years = int(age_text)
             except ValueError:
                 QMessageBox.warning(self, "Edad inválida", "Ingrese la edad en años utilizando solo números enteros.")
                 return
         else:
             age_years = None
         try:
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1600,148 +1625,156 @@ class MainWindow(QMainWindow):
 
         # Obtener lista de pruebas seleccionadas
         selected_tests = [cb.text() for cb in getattr(self, 'test_checkboxes', []) if cb.isChecked()]
 
         if not selected_tests:
             QMessageBox.warning(self, "Sin pruebas", "Seleccione al menos una prueba.")
             return
         duplicate_order = self.labdb.find_recent_duplicate_order(patient_id, selected_tests)
         if duplicate_order:
             reply = QMessageBox.question(
                 self,
                 "Posible duplicado",
                 f"Existe una orden reciente (#{duplicate_order}) con las mismas pruebas. ¿Desea continuar?",
                 QMessageBox.Yes | QMessageBox.No
             )
             if reply == QMessageBox.No:
                 return
         # Crear orden en BD con las pruebas seleccionadas
         order_id = self.labdb.add_order_with_tests(
             patient_id,
             selected_tests,
             self.user['id'],
             observations=observations,
             requested_by=requested_by_text,
             diagnosis=diagnosis,
+            insurance_type=insurance_type,
             age_years=age_years,
             sample_date=sample_date
         )
         QMessageBox.information(self, "Registro exitoso", f"Paciente y pruebas registrados (Orden #{order_id}).")
         # Habilitar botón para ir a anotar resultados de esta orden
         btn_to_results.setEnabled(True)
         self.last_order_registered = order_id
         # Actualizar historial de solicitantes para próximas atenciones
         self.populate_requesters(keep_current=True)
     def clear_registration_form(self):
         # Limpiar todos los campos del formulario de registro
         self.input_doc_number.clear(); self.input_first_name.clear(); self.input_last_name.clear()
         self.input_birth_date.blockSignals(True)
         self.input_birth_date.setDate(QDate.currentDate())
         self.input_birth_date.blockSignals(False)
         self.input_age.clear()
         self.sex_male_radio.setChecked(True)
+        if hasattr(self, 'insurance_combo'):
+            self.insurance_combo.setCurrentIndex(0)
         self.set_origin_value("P.S Iñapari")
         self.input_hcl.clear()
         self.input_height.clear(); self.input_weight.clear(); self.input_blood_pressure.clear()
         self.input_diagnosis.clear()
         self.input_observations.setText("N/A")
         if hasattr(self, 'pregnancy_checkbox'):
             self.pregnancy_checkbox.blockSignals(True)
             self.pregnancy_checkbox.setChecked(False)
             self.pregnancy_checkbox.blockSignals(False)
             self.on_pregnancy_toggle(Qt.Unchecked)
         if hasattr(self, 'gestational_weeks_spin'):
             self.gestational_weeks_spin.setValue(0)
         if hasattr(self, 'expected_delivery_date'):
             self.expected_delivery_date.setDate(QDate.currentDate())
         if hasattr(self, 'sample_date_edit'):
             self.sample_date_edit.blockSignals(True)
             self.sample_date_edit.setDate(QDate.currentDate())
             self.sample_date_edit.blockSignals(False)
         if hasattr(self, 'sample_today_checkbox'):
             self.sample_today_checkbox.setChecked(True)
         if self.input_requested_by.count():
             self.input_requested_by.setCurrentIndex(0)
         if self.input_requested_by.lineEdit():
             self.input_requested_by.lineEdit().clear()
         for cb in getattr(self, 'test_checkboxes', []):
             cb.setChecked(False)
+        self.update_pregnancy_visibility()
 
     def go_to_results(self):
         # Navegar a la página de resultados para la última orden registrada
         if self.last_order_registered:
             self.stack.setCurrentWidget(self.page_resultados)
             self.populate_pending_orders()
             # Seleccionar automáticamente la orden recién creada en el combo
             self._select_order_in_combo(self.combo_orders, self.last_order_registered)
             self.load_order_fields()
     def init_resultados_page(self):
         layout = QVBoxLayout(self.page_resultados)
         search_layout = QHBoxLayout()
         search_label = QLabel("Buscar:")
         self.order_search_input = QLineEdit()
         self.order_search_input.setPlaceholderText("Nombre, documento o # de orden")
         search_layout.addWidget(search_label)
         search_layout.addWidget(self.order_search_input, 1)
         sort_label = QLabel("Ordenar:")
         self.pending_sort_combo = QComboBox()
         self.pending_sort_combo.addItems([
             "Fecha (recientes primero)",
             "Fecha (antiguas primero)",
             "Número de orden (descendente)",
             "Número de orden (ascendente)"
         ])
         search_layout.addWidget(sort_label)
         search_layout.addWidget(self.pending_sort_combo)
         search_layout.addStretch()
         layout.addLayout(search_layout)
         top_layout = QHBoxLayout()
         lbl = QLabel("Orden pendiente:")
         self.combo_orders = QComboBox()
         self.combo_orders.setMinimumWidth(350)
         btn_load = QPushButton("Cargar")
+        self.results_add_tests_btn = QPushButton("Agregar pruebas")
+        self.results_add_tests_btn.setEnabled(False)
         btn_delete_order = QPushButton("Eliminar orden")
         btn_delete_order.setStyleSheet("color: #c0392b;")
         top_layout.addWidget(lbl)
         top_layout.addWidget(self.combo_orders)
         top_layout.addWidget(btn_load)
+        top_layout.addWidget(self.results_add_tests_btn)
         top_layout.addWidget(btn_delete_order)
         layout.addLayout(top_layout)
         # Área scrollable para campos de resultados
         self.results_area = QScrollArea()
         self.results_area.setWidgetResizable(True)
         self.results_container = QWidget()
         self.results_layout = QVBoxLayout(self.results_container)
         self.results_layout.setContentsMargins(10, 10, 10, 10)
         self.results_layout.setSpacing(14)
         self.results_area.setWidget(self.results_container)
         layout.addWidget(self.results_area)
         btn_save = QPushButton("Guardar Resultados")
         layout.addWidget(btn_save)
         btn_load.clicked.connect(self.load_order_fields)
         btn_save.clicked.connect(self.save_results)
         btn_delete_order.clicked.connect(self.delete_order_from_results)
+        self.results_add_tests_btn.clicked.connect(self.add_tests_to_selected_order)
         self.order_search_input.textChanged.connect(self.filter_pending_orders)
         self.pending_sort_combo.currentIndexChanged.connect(
             lambda: self.filter_pending_orders(self.order_search_input.text(), prefer_order=self.selected_order_id)
         )
     def populate_pending_orders(self):
         # Llenar combo de órdenes pendientes (no completadas)
         pending = self.labdb.get_pending_orders()
         self.pending_orders_cache = []
         for row in pending:
             oid, first, last, date, doc_type, doc_number = row
             self.pending_orders_cache.append({
                 "id": oid,
                 "first_name": (first or "").upper(),
                 "last_name": (last or "").upper(),
                 "date": date,
                 "doc_type": doc_type or "",
                 "doc_number": doc_number or ""
             })
         search_text = self.order_search_input.text() if hasattr(self, 'order_search_input') else ""
         prefer_id = self.selected_order_id or self.last_order_registered
         self.filter_pending_orders(search_text, prefer_order=prefer_id)
     def filter_pending_orders(self, text="", prefer_order=None):
         if not hasattr(self, 'combo_orders'):
             return
         filter_text = (text or "").strip().lower()
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1849,81 +1882,85 @@ class MainWindow(QMainWindow):
         for order in sorted_orders:
             self.combo_completed.addItem(self._format_order_display(order), order['id'])
         def normalize_candidate(candidate):
             try:
                 return int(candidate)
             except (TypeError, ValueError):
                 return None
         normalized_prefer = normalize_candidate(prefer_order)
         normalized_current = normalize_candidate(current_data)
         available_ids = {order['id'] for order in sorted_orders}
         target_candidates = [normalized_prefer, normalized_current]
         selected = None
         for candidate in target_candidates:
             if candidate is not None and candidate in available_ids:
                 selected = candidate
                 break
         if selected is not None:
             self._select_order_in_combo(self.combo_completed, selected)
         else:
             self.combo_completed.setCurrentIndex(0)
         self.combo_completed.blockSignals(False)
     def load_order_fields(self):
         # Cargar campos de resultado para la orden seleccionada
         self._clear_results_layout()
         self.order_fields.clear()
+        if hasattr(self, 'results_add_tests_btn'):
+            self.results_add_tests_btn.setEnabled(False)
         data = self.combo_orders.currentData() if hasattr(self, 'combo_orders') else None
         if data is None:
             self.selected_order_id = None
             placeholder = QLabel("Seleccione una orden pendiente para registrar resultados.")
             placeholder.setStyleSheet("color: #555; font-style: italic;")
             placeholder.setWordWrap(True)
             self.results_layout.addWidget(placeholder)
             self.results_layout.addStretch()
             return
         order_id = int(data)
         self.selected_order_id = order_id
         info = self.labdb.get_order_details(order_id)
         if not info:
             empty_label = QLabel("La orden seleccionada no tiene pruebas registradas.")
             empty_label.setStyleSheet("color: #555; font-style: italic;")
             empty_label.setWordWrap(True)
             self.results_layout.addWidget(empty_label)
             self.results_layout.addStretch()
             self.populate_pending_orders()
             return
         patient_info = info.get("patient", {})
         order_info = info.get("order", {})
         rows = info.get("results", [])
         self.current_order_context = {"patient": patient_info, "order": order_info}
         if not rows:
             empty_label = QLabel("La orden seleccionada no tiene pruebas asociadas.")
             empty_label.setStyleSheet("color: #555; font-style: italic;")
             empty_label.setWordWrap(True)
             self.results_layout.addWidget(empty_label)
             self.results_layout.addStretch()
             return
+        if hasattr(self, 'results_add_tests_btn'):
+            self.results_add_tests_btn.setEnabled(True)
         order_test_names = [name for (name, *_rest) in rows]
         for entry in rows:
             (
                 test_name,
                 raw_result,
                 category,
                 sample_status,
                 sample_issue,
                 observation,
                 _entry_id
             ) = entry
             template = None
             template_name = test_name
             if test_name == "Hematocrito":
                 auto_mode = self._should_auto_calculate_hb(order_test_names)
                 template = build_hematocrit_template(auto_mode)
                 if auto_mode:
                     template_name = "Hematocrito (automático)"
                     TEST_TEMPLATES[template_name] = copy.deepcopy(template)
             else:
                 base_template = TEST_TEMPLATES.get(test_name)
                 if base_template is not None:
                     template = copy.deepcopy(base_template)
                 elif category == "PRUEBAS RÁPIDAS":
                     template = build_bool_observation_template()
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2136,50 +2173,52 @@ class MainWindow(QMainWindow):
             QMessageBox.information(self, "Completado", "Resultados guardados. Orden marcada como completada.")
             self.selected_order_id = None
             self.populate_pending_orders()
             self._clear_results_layout()
             msg = QLabel("Seleccione otra orden pendiente para continuar con la digitación de resultados.")
             msg.setStyleSheet("color: #555; font-style: italic;")
             msg.setWordWrap(True)
             self.results_layout.addWidget(msg)
             self.results_layout.addStretch()
         else:
             message = "Resultados guardados (orden aún incompleta)."
             if pending_samples:
                 message += "\nHay muestras pendientes o rechazadas registradas."
             QMessageBox.information(self, "Guardado", message)
             self.load_order_fields()
 
     def _clear_results_layout(self):
         if not hasattr(self, 'results_layout'):
             return
         self.current_order_context = None
         while self.results_layout.count():
             item = self.results_layout.takeAt(0)
             widget = item.widget()
             if widget:
                 widget.deleteLater()
+        if hasattr(self, 'results_add_tests_btn'):
+            self.results_add_tests_btn.setEnabled(False)
     def _create_structured_field(self, field_def, existing_values, context=None):
         key = field_def.get("key")
         value = ""
         if key:
             value = existing_values.get(key, "")
         container = QWidget()
         layout = QHBoxLayout(container)
         layout.setContentsMargins(0, 0, 0, 0)
         layout.setSpacing(6)
         widget_info = {"key": key, "container": container}
         field_type = field_def.get("type", "text")
         if field_type == "choice":
             combo = QComboBox()
             combo.addItems(field_def.get("choices", []))
             if value:
                 idx = combo.findText(value)
                 if idx >= 0:
                     combo.setCurrentIndex(idx)
                 else:
                     combo.addItem(value)
                     combo.setCurrentIndex(combo.count() - 1)
             else:
                 if combo.count():
                     combo.setCurrentIndex(-1)
             layout.addWidget(combo)
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2684,54 +2723,58 @@ class MainWindow(QMainWindow):
             summary_items = record.get("summary_items")
             if not summary_items:
                 result_value = record.get("result", "")
                 if isinstance(result_value, str) and result_value.strip():
                     summary_items = [result_value.strip()]
                 elif not self._is_blank_result(result_value):
                     summary_items = [str(result_value)]
             if not summary_items:
                 continue
             order_id = record.get("order_id")
             if order_id is None:
                 continue
             entry = grouped.get(order_id)
             if not entry:
                 entry = {
                     "order_id": order_id,
                     "date": record.get("date", ""),
                     "order_date_raw": record.get("order_date_raw"),
                     "sample_date_raw": record.get("sample_date_raw"),
                     "patient": record.get("patient", ""),
                     "document": record.get("document", ""),
                     "doc_type": record.get("doc_type"),
                     "doc_number": record.get("doc_number"),
                     "birth_date": record.get("birth_date"),
                     "hcl": record.get("hcl"),
+                    "sex": record.get("sex"),
+                    "origin": record.get("origin"),
                     "age": record.get("age", ""),
                     "first_name": record.get("first_name"),
                     "last_name": record.get("last_name"),
                     "observations": record.get("order_observations"),
+                    "insurance_type": record.get("insurance_type"),
+                    "fua_number": record.get("fua_number"),
                     "emitted": record.get("emitted"),
                     "emitted_at": record.get("emitted_at"),
                     "groups": {key: [] for key in group_keys},
                     "tests": []
                 }
                 grouped[order_id] = entry
             group_key = self._map_category_group(record.get("category"))
             for item in summary_items:
                 cleaned = str(item).strip()
                 if cleaned:
                     entry["groups"].setdefault(group_key, []).append(cleaned)
             test_name = record.get("test")
             if test_name:
                 test_clean = str(test_name).strip()
                 if test_clean and test_clean not in entry.setdefault("tests", []):
                     entry["tests"].append(test_clean)
         for entry in grouped.values():
             obs_text = entry.get("observations")
             if obs_text:
                 obs_clean = " ".join(str(obs_text).split())
                 if obs_clean and obs_clean.lower() not in {"n/a", "na", "-"}:
                     entry["groups"].setdefault("others", []).append(f"Obs: {obs_clean}")
             if any(entry["groups"].get(key) for key in group_keys):
                 aggregated.append(entry)
         return aggregated
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2780,50 +2823,85 @@ class MainWindow(QMainWindow):
         hcl_line = f"HCL: {hcl_value}"
         return "\n".join([name_line or "—", doc_line, birth_line, hcl_line])
 
     def _format_date_for_registry(self, entry):
         sample = entry.get("sample_date_raw")
         if sample:
             formatted = self._format_short_date(sample)
             if formatted:
                 return formatted
         raw_date = entry.get("order_date_raw") or entry.get("date")
         return self._format_short_date(raw_date)
 
     def _format_emission_status(self, emitted_flag, emitted_at):
         if emitted_flag:
             if emitted_at:
                 try:
                     parsed = datetime.datetime.strptime(emitted_at, "%Y-%m-%d %H:%M:%S")
                     return f"Sí ({parsed.strftime('%d/%m/%Y')})"
                 except Exception:
                     return "Sí"
             return "Sí"
         if emitted_flag == 0:
             return "No"
         return "-"
 
+    def _format_birth_for_history(self, birth_value):
+        if not birth_value:
+            return "-"
+        display = self._format_short_date(birth_value)
+        return "-" if display == "—" else display
+
+    def _format_sex_display(self, sex_value):
+        if sex_value in (None, ""):
+            return "-"
+        text = str(sex_value).strip()
+        if not text:
+            return "-"
+        normalized = text.lower()
+        if normalized.startswith("f"):
+            return "F"
+        if normalized.startswith("m"):
+            return "M"
+        return text.title()
+
+    def _format_insurance_display(self, insurance_value):
+        if not insurance_value:
+            return "SIS"
+        return str(insurance_value).strip().upper() or "SIS"
+
+    def _format_fua_display(self, entry):
+        insurance = (entry.get("insurance_type") or "").strip().lower()
+        fua_value = entry.get("fua_number")
+        if insurance == "particular":
+            return "No aplica"
+        if isinstance(fua_value, str):
+            fua_value = fua_value.strip()
+        if fua_value:
+            return str(fua_value)
+        return "Pendiente"
+
     def _format_sample_status_text(self, status_value, note):
         value = (status_value or "recibida").strip().lower()
         if value == "recibida":
             return ""
         label = "Pendiente" if value == "pendiente" else "Rechazada"
         if note:
             return f"{label} - {note}"
         return label
     def _calculate_age_years(self, patient_info, order_info):
         age_value = order_info.get('age_years') if isinstance(order_info, dict) else None
         if age_value is not None:
             try:
                 return int(age_value)
             except (TypeError, ValueError):
                 age_value = None
         if age_value is None:
             birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     age_value = bd.daysTo(QDate.currentDate()) // 365
         return age_value
     def _format_age_text(self, patient_info, order_info):
         age_value = self._calculate_age_years(patient_info, order_info)
         return f"{age_value} años" if age_value is not None else "-"
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3130,130 +3208,161 @@ class MainWindow(QMainWindow):
             return
         dialog = ReasonDialog(
             "Motivo de eliminación",
             "Indique el motivo por el que se elimina la orden.",
             self,
             placeholder="Motivo (ej. duplicado, prueba, error de digitación)"
         )
         dialog.text_edit.setPlainText("Duplicidad de registro")
         if dialog.exec_() != QDialog.Accepted:
             return
         reason = dialog.get_reason() or "Sin motivo"
         deleted = self.labdb.mark_order_deleted(order_id, reason, self.user.get('id'))
         if deleted:
             QMessageBox.information(self, "Orden eliminada", f"La orden #{order_id} fue eliminada correctamente.")
             if getattr(self, 'selected_order_id', None) == order_id:
                 self.selected_order_id = None
             self.populate_pending_orders()
             self.populate_completed_orders()
             self.load_activity_summary()
             self.output_text.clear()
             self._clear_results_layout()
         else:
             QMessageBox.warning(self, "Sin cambios", "No se pudo eliminar la orden seleccionada.")
 
     def add_tests_to_selected_order(self):
-        data = self.combo_completed.currentData() if hasattr(self, 'combo_completed') else None
-        if data is None:
-            QMessageBox.information(self, "Sin selección", "Seleccione una orden para agregar pruebas adicionales.")
-            return
-        order_id = int(data)
+        sender = self.sender()
+        triggered_from_results = sender == getattr(self, 'results_add_tests_btn', None)
+        order_id = None
+        if triggered_from_results:
+            if self.selected_order_id:
+                order_id = int(self.selected_order_id)
+            elif hasattr(self, 'combo_orders'):
+                data = self.combo_orders.currentData()
+                if data is not None:
+                    order_id = int(data)
+            if not order_id:
+                QMessageBox.information(self, "Sin selección", "Cargue una orden pendiente antes de agregar pruebas.")
+                return
+        else:
+            data = self.combo_completed.currentData() if hasattr(self, 'combo_completed') else None
+            if data is None:
+                QMessageBox.information(self, "Sin selección", "Seleccione una orden para agregar pruebas adicionales.")
+                return
+            order_id = int(data)
         all_tests = self.labdb.get_all_tests()
         existing = self.labdb.get_tests_for_order(order_id)
         dialog = AddTestsDialog(all_tests, existing, self)
         if dialog.exec_() != QDialog.Accepted:
             return
         selected = dialog.get_selected_tests()
         if not selected:
             QMessageBox.information(self, "Sin cambios", "No se seleccionaron nuevas pruebas.")
             return
         added = self.labdb.add_tests_to_order(order_id, selected)
         if not added:
             QMessageBox.information(self, "Sin cambios", "Las pruebas seleccionadas ya estaban asociadas a la orden.")
             return
-        QMessageBox.information(
-            self,
-            "Pruebas agregadas",
-            "Se agregaron {0} prueba(s). Registre los resultados antes de emitir nuevamente.".format(len(added))
-        )
-        self.selected_order_id = order_id
-        self.populate_pending_orders()
-        self.populate_completed_orders()
-        reply = QMessageBox.question(
-            self,
-            "Registrar resultados",
-            "¿Desea ir a la pantalla de resultados para completar las nuevas pruebas?",
-            QMessageBox.Yes | QMessageBox.No
-        )
-        if reply == QMessageBox.Yes:
-            self.stack.setCurrentWidget(self.page_resultados)
-            if hasattr(self, 'combo_orders'):
-                self._select_order_in_combo(self.combo_orders, order_id)
+        if triggered_from_results:
+            QMessageBox.information(
+                self,
+                "Pruebas agregadas",
+                "Se agregaron {0} prueba(s). Las nuevas pruebas aparecerán en el formulario.".format(len(added))
+            )
+            self.selected_order_id = order_id
+            self.populate_pending_orders()
             self.load_order_fields()
+        else:
+            QMessageBox.information(
+                self,
+                "Pruebas agregadas",
+                "Se agregaron {0} prueba(s). Registre los resultados antes de emitir nuevamente.".format(len(added))
+            )
+            self.selected_order_id = order_id
+            self.populate_pending_orders()
+            self.populate_completed_orders()
+            reply = QMessageBox.question(
+                self,
+                "Registrar resultados",
+                "¿Desea ir a la pantalla de resultados para completar las nuevas pruebas?",
+                QMessageBox.Yes | QMessageBox.No
+            )
+            if reply == QMessageBox.Yes:
+                self.stack.setCurrentWidget(self.page_resultados)
+                if hasattr(self, 'combo_orders'):
+                    self._select_order_in_combo(self.combo_orders, order_id)
+                self.load_order_fields()
 
     def display_selected_result(self):
         # Mostrar los resultados de la orden seleccionada en el cuadro de texto
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
             return
         pat = info["patient"]
         ord_inf = info["order"]
         results = info["results"]
         context = {"patient": pat, "order": ord_inf}
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
         lines = [f"PACIENTE: {pat.get('name') or '-'}", f"DOCUMENTO: {doc_text}"]
         age_value = self._calculate_age_years(pat, ord_inf)
         lines.append(f"EDAD: {age_value} AÑOS" if age_value is not None else "EDAD: -")
         lines.append(f"SEXO: {pat.get('sex') or '-'}")
         pregnancy_flag = pat.get('is_pregnant')
         gest_weeks = pat.get('gestational_age_weeks')
         due_raw = pat.get('expected_delivery_date')
         if pregnancy_flag or due_raw or gest_weeks not in (None, ''):
             if pregnancy_flag:
                 weeks_text = ''
                 if gest_weeks not in (None, '', 0):
                     try:
                         weeks_text = f"{int(gest_weeks)} SEMANAS"
                     except (TypeError, ValueError):
                         weeks_text = ''
                 line = 'GESTANTE: SÍ'
                 if weeks_text:
                     line += f" ({weeks_text})"
             else:
                 line = 'GESTANTE: NO'
             lines.append(line)
             if due_raw:
                 due_display = self._format_short_date(due_raw)
                 if due_display == '—':
                     due_display = due_raw
                 lines.append(f"FPP: {due_display}")
         lines.append(f"HISTORIA CLÍNICA: {pat.get('hcl') or '-'}")
         lines.append(f"PROCEDENCIA: {pat.get('origin') or '-'}")
+        insurance_display = self._format_insurance_display(ord_inf.get('insurance_type'))
+        fua_display = self._format_fua_display({
+            "insurance_type": ord_inf.get('insurance_type'),
+            "fua_number": ord_inf.get('fua_number')
+        })
+        lines.append(f"SEGURO: {insurance_display}")
+        lines.append(f"FUA: {fua_display}")
         requester = ord_inf.get('requested_by') or '-'
         lines.append(f"SOLICITANTE: {requester}")
         emission_raw = ord_inf.get('emitted_at')
         if emission_raw:
             try:
                 emission_dt = datetime.datetime.strptime(emission_raw, "%Y-%m-%d %H:%M:%S")
                 emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 emission_display = emission_raw
         else:
             emission_display = "Pendiente de emisión"
         lines.append(f"FECHA DEL INFORME: {emission_display}")
         sample_raw = ord_inf.get('sample_date')
         if sample_raw:
             try:
                 sample_dt = datetime.datetime.strptime(sample_raw, "%Y-%m-%d")
                 sample_display = sample_dt.strftime("%d/%m/%Y")
             except Exception:
                 sample_display = sample_raw
         else:
             sample_display = "-"
         lines.append(f"FECHA DE TOMA DE MUESTRA: {sample_display}")
         lines.append("RESULTADOS:")
         for test_name, raw_result, _, sample_status, sample_issue, observation, _ in results:
             formatted_lines = self._format_result_lines(test_name, raw_result, context=context)
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3368,53 +3477,59 @@ class MainWindow(QMainWindow):
                 due_display = due_raw
         pregnancy_text = None
         if pregnancy_flag or due_raw or gest_weeks not in (None, ''):
             if pregnancy_flag:
                 weeks_text = ''
                 if gest_weeks not in (None, '', 0):
                     try:
                         weeks_text = f"{int(gest_weeks)} sem"
                     except (TypeError, ValueError):
                         weeks_text = ''
                 pregnancy_text = 'Sí'
                 if weeks_text:
                     pregnancy_text = f"{pregnancy_text} ({weeks_text})"
             else:
                 pregnancy_text = 'No'
         sample_date_raw = ord_inf.get('sample_date')
         sample_date_display = '-'
         if sample_date_raw:
             try:
                 sample_dt = datetime.datetime.strptime(sample_date_raw, "%Y-%m-%d")
                 sample_date_display = sample_dt.strftime("%d/%m/%Y")
             except Exception:
                 sample_date_display = sample_date_raw
         if not print_display:
             print_display = emission_display
+        insurance_display = self._format_insurance_display(ord_inf.get('insurance_type'))
+        fua_display = self._format_fua_display({
+            "insurance_type": ord_inf.get('insurance_type'),
+            "fua_number": ord_inf.get('fua_number')
+        })
         info_pairs = [
             (("Paciente", patient_name), ("Edad", age_text)),
             (("Documento", doc_text.upper() if doc_text else "-"), ("Sexo", sex_text)),
+            (("Seguro", insurance_display), ("FUA", fua_display)),
             (("Historia clínica", hcl_text), ("Fecha del informe", emission_display)),
             (("Procedencia", origin_text), ("Fecha de toma de muestra", sample_date_display)),
             (("Solicitante", requester_text), ("Diagnóstico", diagnosis_text)),
         ]
         if pregnancy_text:
             info_pairs.append((("Gestante", pregnancy_text), ("FPP", due_display)))
 
         def draw_patient_info():
             col_width = (pdf.w - pdf.l_margin - pdf.r_margin) / 2
 
             def wrap_value_lines(text, width):
                 safe_value = str(text) if text not in (None, "") else "-"
                 safe_value = self._ensure_latin1(safe_value)
                 segments = []
                 for part in safe_value.split('\n'):
                     part = part.strip()
                     if part:
                         segments.append(part)
                 if not segments:
                     segments = [safe_value.strip() or "-"]
                 lines = []
                 for segment in segments:
                     words = segment.split()
                     if not words:
                         lines.append("-")
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3852,85 +3967,96 @@ class MainWindow(QMainWindow):
             "Fecha",
             "Orden",
             "Paciente",
             "Documento",
             "Edad",
             "Prueba",
             "Estado",
             "Resultado"
         ])
         self.activity_table.setAlternatingRowColors(True)
         self.activity_table.horizontalHeader().setStretchLastSection(True)
         self.activity_table.setSelectionMode(QTableWidget.MultiSelection)
         layout.addWidget(self.activity_table)
         history_group = QGroupBox("Historial por DNI")
         history_layout = QVBoxLayout(history_group)
         history_search_layout = QHBoxLayout()
         history_search_layout.addWidget(QLabel("DNI:"))
         self.history_doc_input = QLineEdit()
         self.history_doc_input.setPlaceholderText("Ingrese DNI")
         history_search_layout.addWidget(self.history_doc_input)
         self.history_search_btn = QPushButton("Buscar")
         history_search_layout.addWidget(self.history_search_btn)
         self.history_open_btn = QPushButton("Ver en emisión")
         self.history_open_btn.setEnabled(False)
         history_search_layout.addWidget(self.history_open_btn)
+        self.history_fua_btn = QPushButton("Registrar FUA")
+        self.history_fua_btn.setEnabled(False)
+        history_search_layout.addWidget(self.history_fua_btn)
         history_search_layout.addStretch()
         history_layout.addLayout(history_search_layout)
         history_headers = [
             "Fecha",
             "Orden",
             "Paciente",
             "Documento",
+            "F. Nacimiento",
             "Edad",
+            "Sexo",
+            "Procedencia",
+            "HCL",
+            "Tipo de seguro",
+            "FUA",
             "Hematología",
             "Bioquímica",
             "Micro/Parasitología",
             "Otros exámenes",
             "Emitido"
         ]
         self.history_table = QTableWidget(0, len(history_headers))
         self.history_table.setHorizontalHeaderLabels(history_headers)
         self.history_table.setSelectionBehavior(QTableWidget.SelectRows)
         self.history_table.setSelectionMode(QTableWidget.SingleSelection)
         self.history_table.setAlternatingRowColors(True)
         self.history_table.setWordWrap(True)
         self.history_table.verticalHeader().setVisible(False)
         self.history_table.horizontalHeader().setStretchLastSection(True)
+        self.history_column_map = {header: idx for idx, header in enumerate(history_headers)}
         history_layout.addWidget(self.history_table)
         layout.addWidget(history_group)
         self._history_results = []
         self.range_combo.currentIndexChanged.connect(self._update_range_controls)
         self.view_activity_btn.clicked.connect(self.load_activity_summary)
         self.export_activity_pdf_btn.clicked.connect(lambda: self.export_activity_record("pdf"))
         self.export_activity_csv_btn.clicked.connect(lambda: self.export_activity_record("csv"))
         self.delete_activity_btn.clicked.connect(self.delete_selected_activity_entries)
         self._update_range_controls()
         self.history_doc_input.returnPressed.connect(self.search_patient_history)
         self.history_search_btn.clicked.connect(self.search_patient_history)
         self.history_open_btn.clicked.connect(self.open_history_order_from_analysis)
         self.history_table.itemSelectionChanged.connect(self._on_history_selection_changed)
+        self.history_fua_btn.clicked.connect(self.edit_history_fua)
     def refresh_statistics(self):
         stats = self.labdb.get_statistics()
         text = (f"Pacientes registrados: {stats['total_patients']}\n"
                 f"Órdenes realizadas: {stats['total_orders']}\n"
                 f"Pruebas realizadas: {stats['total_tests_conducted']}")
         self.stats_label.setText(text)
         # Llenar tabla de categorías
         self.stats_table.setRowCount(0)
         for (cat, count) in stats['by_category']:
             row = self.stats_table.rowCount()
             self.stats_table.insertRow(row)
             self.stats_table.setItem(row, 0, QTableWidgetItem(cat))
             self.stats_table.setItem(row, 1, QTableWidgetItem(str(count)))
         self.load_activity_summary()
 
     def _update_range_controls(self):
         if not hasattr(self, 'range_combo'):
             return
         is_custom = self.range_combo.currentIndex() == 4
         if hasattr(self, 'start_date_edit'):
             self.start_date_edit.setEnabled(is_custom)
         if hasattr(self, 'end_date_edit'):
             self.end_date_edit.setEnabled(is_custom)
         if not is_custom and hasattr(self, 'start_date_edit') and hasattr(self, 'end_date_edit'):
             today = QDate.currentDate()
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3980,101 +4106,108 @@ class MainWindow(QMainWindow):
         end_dt = datetime.datetime.combine(end_date, datetime.time.max)
         return start_dt, end_dt, description
 
 
     def load_activity_summary(self):
         if not hasattr(self, 'activity_table'):
             return
         start_dt, end_dt, description = self._get_selected_range()
         rows = self.labdb.get_results_in_range(
             start_dt.strftime("%Y-%m-%d %H:%M:%S"),
             end_dt.strftime("%Y-%m-%d %H:%M:%S")
         )
         activity_data = []
         for (
             test_entry_id,
             order_id,
             date_str,
             sample_date_str,
             first,
             last,
             doc_type,
             doc_number,
             sex,
             birth_date,
             hcl,
+            origin,
             age_years,
             order_obs,
+            insurance_type,
+            fua_number,
             test_name,
             category,
             result,
             sample_status,
             sample_issue,
             observation
         ) in rows:
             display_date = "-"
             if sample_date_str:
                 try:
                     sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
                     display_date = sample_dt.strftime("%d/%m/%Y")
                 except Exception:
                     display_date = sample_date_str
             if display_date == "-":
                 try:
                     order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
                     display_date = order_dt.strftime("%d/%m/%Y %H:%M")
                 except Exception:
                     display_date = date_str or "-"
             patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
             context = {
                 "patient": {"sex": sex, "birth_date": birth_date},
                 "order": {"age_years": age_years}
             }
             summary_items = self._build_registry_summary(test_name, result, context=context)
             if not summary_items:
                 continue
             result_text = "; ".join(summary_items)
             activity_data.append({
                 "entry_id": test_entry_id,
                 "order_id": order_id,
                 "date": display_date,
                 "order_date_raw": date_str,
                 "sample_date_raw": sample_date_str,
                 "patient": patient_name,
                 "document": doc_text,
                 "doc_type": doc_type,
                 "doc_number": doc_number,
                 "birth_date": birth_date,
                 "hcl": hcl,
+                "sex": sex,
+                "origin": origin,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "summary_items": summary_items,
                 "category": category,
                 "order_observations": order_obs,
+                "insurance_type": insurance_type,
+                "fua_number": fua_number,
                 "emitted": None,
                 "emitted_at": None,
                 "first_name": first,
                 "last_name": last,
                 "sample_status": sample_status,
                 "sample_issue": sample_issue,
                 "observation": observation
             })
         self._activity_cache = {
             "data": activity_data,
             "description": description,
             "start": start_dt,
             "end": end_dt
         }
         self.activity_table.setRowCount(len(activity_data))
         for row_idx, item in enumerate(activity_data):
             self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
             order_item = QTableWidgetItem(str(item["order_id"]))
             order_item.setTextAlignment(Qt.AlignCenter)
             self.activity_table.setItem(row_idx, 1, order_item)
             self.activity_table.setItem(row_idx, 2, QTableWidgetItem(item["patient"]))
             self.activity_table.setItem(row_idx, 3, QTableWidgetItem(item["document"]))
             age_item = QTableWidgetItem(item["age"])
             age_item.setTextAlignment(Qt.AlignCenter)
             self.activity_table.setItem(row_idx, 4, age_item)
diff --git a/main_window.py b/main_window.py
index 47d2f7950a87248351d5837c04625690011a43eb..1e2ddbcd60ba3fff2987df24ad59d0e6a6639a52 100644
--- a/main_window.py
+++ b/main_window.py
@@ -4471,200 +4604,281 @@ class MainWindow(QMainWindow):
                 pdf.rect(row_start_x, row_start_y, width, row_height)
                 text_y = row_start_y + padding_y
                 for line in wrapped[idx]:
                     pdf.set_xy(row_start_x + padding_x, text_y)
                     pdf.cell(width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
                 row_start_x += width
             pdf.set_xy(pdf.l_margin, row_start_y + row_height)
         pdf.set_margins(prev_left, prev_top, prev_right)
         pdf.set_auto_page_break(prev_auto, margin=prev_bottom)
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
 
     def _on_history_selection_changed(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         has_selection = bool(selection.selectedRows()) if selection else False
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(has_selection)
+        if hasattr(self, 'history_fua_btn'):
+            enable_fua = False
+            tooltip = ""
+            if has_selection and selection:
+                indexes = selection.selectedRows()
+                if indexes:
+                    row = indexes[0].row()
+                    history_items = getattr(self, '_history_results', [])
+                    if 0 <= row < len(history_items):
+                        entry = history_items[row]
+                        insurance = (entry.get("insurance_type") or "").strip().lower()
+                        if insurance == "particular":
+                            tooltip = "Las atenciones particulares no requieren FUA."
+                        else:
+                            enable_fua = True
+            self.history_fua_btn.setEnabled(enable_fua)
+            self.history_fua_btn.setToolTip(tooltip)
 
 
     def search_patient_history(self):
         if not hasattr(self, 'history_table'):
             return
         doc_number = self.history_doc_input.text().strip() if hasattr(self, 'history_doc_input') else ""
         if doc_number == "":
             QMessageBox.warning(self, "DNI requerido", "Ingrese un DNI para realizar la búsqueda.")
             return
         if not doc_number.isdigit():
             QMessageBox.warning(self, "Formato inválido", "El DNI debe contener solo números.")
             return
         self._clear_history_table()
         rows = self.labdb.get_patient_history_by_document(doc_number, "DNI")
         records = []
         for row in rows:
             (
                 order_id,
                 date_str,
                 sample_date_str,
                 test_name,
                 raw_result,
                 category,
                 first_name,
                 last_name,
                 doc_type,
                 doc_value,
                 sex,
                 birth_date,
                 hcl,
+                origin,
                 age_years,
                 order_obs,
+                insurance_type,
+                fua_number,
                 emitted,
                 emitted_at,
                 sample_status,
                 sample_issue,
                 observation,
                 entry_id
             ) = row
             display_date = "-"
             if sample_date_str:
                 try:
                     sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
                     display_date = sample_dt.strftime("%d/%m/%Y")
                 except Exception:
                     display_date = sample_date_str
             if display_date == "-":
                 try:
                     order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
                     display_date = order_dt.strftime("%d/%m/%Y %H:%M")
                 except Exception:
                     display_date = date_str or "-"
             patient_name = " ".join(part for part in [(first_name or "").upper(), (last_name or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_value) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
             context = {
                 "patient": {"sex": sex, "birth_date": birth_date},
                 "order": {"age_years": age_years}
             }
             summary_items = self._build_registry_summary(test_name, raw_result, context=context)
             if not summary_items:
                 continue
             result_text = "; ".join(summary_items)
             records.append({
                 "entry_id": entry_id,
                 "order_id": order_id,
                 "date": display_date,
                 "order_date_raw": date_str,
                 "sample_date_raw": sample_date_str,
                 "patient": patient_name,
                 "document": doc_text,
                 "doc_type": doc_type,
                 "doc_number": doc_value,
                 "birth_date": birth_date,
                 "hcl": hcl,
+                "sex": sex,
+                "origin": origin,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "summary_items": summary_items,
                 "category": category,
                 "order_observations": order_obs,
+                "insurance_type": insurance_type,
+                "fua_number": fua_number,
                 "emitted": emitted,
                 "emitted_at": emitted_at,
                 "first_name": first_name,
                 "last_name": last_name,
                 "sample_status": sample_status,
                 "sample_issue": sample_issue,
                 "observation": observation
             })
         aggregated = self._aggregate_results_by_order(records)
         self._history_results = aggregated
         self.history_table.setRowCount(len(aggregated))
         headers = [
             "date",
             "order_id",
             "patient",
             "document",
+            "birth",
             "age",
+            "sex",
+            "origin",
+            "hcl",
+            "insurance",
+            "fua",
             "hematology",
             "biochemistry",
             "micro_parasito",
             "others",
             "emitted"
         ]
         for row_idx, entry in enumerate(aggregated):
             values = [
                 self._format_date_for_registry(entry),
                 str(entry.get("order_id", "-")),
                 entry.get("patient", "-"),
                 entry.get("document", "-"),
+                self._format_birth_for_history(entry.get("birth_date")),
                 entry.get("age", "-"),
+                self._format_sex_display(entry.get("sex")),
+                entry.get("origin", "-") or "-",
+                entry.get("hcl", "-") or "-",
+                self._format_insurance_display(entry.get("insurance_type")),
+                self._format_fua_display(entry),
                 "\n  ".join(entry.get("groups", {}).get("hematology", [])) or "-",
                 "\n  ".join(entry.get("groups", {}).get("biochemistry", [])) or "-",
                 "\n  ".join(entry.get("groups", {}).get("micro_parasito", [])) or "-",
                 "\n  ".join(entry.get("groups", {}).get("others", [])) or "-",
                 self._format_emission_status(entry.get("emitted"), entry.get("emitted_at"))
             ]
             for col_idx, value in enumerate(values):
                 item = QTableWidgetItem(str(value))
-                if headers[col_idx] in {"order_id", "age"}:
+                if headers[col_idx] in {"order_id", "age", "birth", "sex", "insurance", "fua"}:
                     item.setTextAlignment(Qt.AlignCenter)
                 self.history_table.setItem(row_idx, col_idx, item)
         if not aggregated:
             QMessageBox.information(self, "Sin resultados", "No se encontró historial con resultados registrados para este DNI.")
         self._on_history_selection_changed()
 
     def open_history_order_from_analysis(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         if not selection:
             return
         indexes = selection.selectedRows()
         if not indexes:
             QMessageBox.information(self, "Sin selección", "Seleccione una orden para abrirla en la emisión.")
             return
         row = indexes[0].row()
         history_items = getattr(self, '_history_results', [])
         if row >= len(history_items):
             return
         order_id = history_items[row].get("order_id")
         if not order_id:
             QMessageBox.warning(self, "Orden no disponible", "No se pudo determinar el número de orden seleccionado.")
             return
         if hasattr(self, 'include_emitted_checkbox'):
             self.include_emitted_checkbox.setChecked(True)
         self.populate_completed_orders()
         self._select_order_in_combo(self.combo_completed, order_id)
         self.display_selected_result()
         self.stack.setCurrentWidget(self.page_emitir)
+
+    def edit_history_fua(self):
+        if not hasattr(self, 'history_table'):
+            return
+        selection = self.history_table.selectionModel()
+        if not selection or not selection.selectedRows():
+            QMessageBox.information(self, "Sin selección", "Seleccione una orden para registrar su FUA.")
+            return
+        row = selection.selectedRows()[0].row()
+        history_items = getattr(self, '_history_results', [])
+        if row >= len(history_items):
+            return
+        entry = history_items[row]
+        insurance = (entry.get("insurance_type") or "").strip().lower()
+        if insurance == "particular":
+            QMessageBox.information(self, "FUA no requerido", "Esta atención es Particular, no requiere FUA.")
+            return
+        order_id = entry.get("order_id")
+        if not order_id:
+            QMessageBox.warning(self, "Orden no disponible", "No se pudo identificar la orden seleccionada.")
+            return
+        current_value = entry.get("fua_number") or ""
+        text, ok = QInputDialog.getText(
+            self,
+            "Registrar FUA",
+            f"Ingrese el número de FUA para la orden #{order_id}:",
+            QLineEdit.Normal,
+            current_value
+        )
+        if not ok:
+            return
+        new_value = text.strip()
+        updated = self.labdb.update_order_fua(order_id, new_value)
+        if not updated:
+            QMessageBox.warning(self, "Sin cambios", "No se pudo actualizar el número de FUA.")
+            return
+        entry["fua_number"] = new_value
+        fua_text = self._format_fua_display(entry)
+        fua_col = getattr(self, 'history_column_map', {}).get("FUA") if hasattr(self, 'history_column_map') else None
+        if fua_col is not None:
+            item = QTableWidgetItem(fua_text)
+            item.setTextAlignment(Qt.AlignCenter)
+            self.history_table.setItem(row, fua_col, item)
+        QMessageBox.information(self, "FUA actualizado", "El número de FUA se registró correctamente.")
+        self._on_history_selection_changed()
     def init_config_page(self):
         layout = QVBoxLayout(self.page_config)
         profile_group = QGroupBox("Datos del usuario actual")
         profile_layout = QFormLayout(profile_group)
         self.profile_full_name_input = QLineEdit()
         profile_layout.addRow("Nombre completo:", self.profile_full_name_input)
         self.profile_profession_input = QLineEdit()
         profile_layout.addRow("Profesión / Cargo:", self.profile_profession_input)
         self.profile_license_input = QLineEdit()
         profile_layout.addRow("Colegiatura / Registro:", self.profile_license_input)
         btn_save_profile = QPushButton("Guardar perfil")
         btn_save_profile.clicked.connect(self.save_user_profile)
         profile_layout.addRow(btn_save_profile)
         layout.addWidget(profile_group)
         self._populate_profile_fields()
         info_label = QLabel("Crear nuevo usuario:")
         layout.addWidget(info_label)
         form_layout = QFormLayout()
         self.new_user_input = QLineEdit(); form_layout.addRow("Usuario:", self.new_user_input)
         self.new_pass_input = QLineEdit(); self.new_pass_input.setEchoMode(QLineEdit.Password)
         form_layout.addRow("Contraseña:", self.new_pass_input)
         self.new_user_full_name = QLineEdit(); form_layout.addRow("Nombre completo:", self.new_user_full_name)
         self.new_user_profession = QLineEdit(); form_layout.addRow("Profesión / Cargo:", self.new_user_profession)
         self.new_user_license = QLineEdit(); form_layout.addRow("Colegiatura / Registro:", self.new_user_license)
         self.role_input = QComboBox(); self.role_input.addItems(["Administrador", "Superusuario"])
