diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1027,50 +1027,111 @@ class AddTestsDialog(QDialog):
         layout = QVBoxLayout(self)
         description = QLabel("Seleccione las pruebas adicionales que desea agregar a la orden actual.")
         description.setWordWrap(True)
         layout.addWidget(description)
         self.list_widget = QListWidget()
         self.list_widget.setSelectionMode(QListWidget.MultiSelection)
         disabled_set = set(disabled_tests or [])
         for name, category in tests:
             display_text = f"{name} ({category})" if category else name
             item = QListWidgetItem(display_text)
             item.setData(Qt.UserRole, name)
             if name in disabled_set:
                 item.setFlags(item.flags() & ~Qt.ItemIsEnabled)
                 item.setText(f"{display_text} - ya incluido")
             self.list_widget.addItem(item)
         layout.addWidget(self.list_widget)
         buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
         buttons.accepted.connect(self.accept)
         buttons.rejected.connect(self.reject)
         layout.addWidget(buttons)
 
     def get_selected_tests(self):
         return [item.data(Qt.UserRole) for item in self.list_widget.selectedItems() if item.flags() & Qt.ItemIsEnabled]
 
 
+class ReasonDialog(QDialog):
+    def __init__(self, title, prompt, parent=None, placeholder="Describa el motivo" ):
+        super().__init__(parent)
+        self.setWindowTitle(title)
+        self.setMinimumWidth(420)
+        layout = QVBoxLayout(self)
+        label = QLabel(prompt)
+        label.setWordWrap(True)
+        layout.addWidget(label)
+        self.text_edit = QTextEdit()
+        self.text_edit.setPlaceholderText(placeholder)
+        self.text_edit.setFixedHeight(120)
+        layout.addWidget(self.text_edit)
+        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        self.buttons.accepted.connect(self.accept)
+        self.buttons.rejected.connect(self.reject)
+        layout.addWidget(self.buttons)
+
+    def get_reason(self):
+        return self.text_edit.toPlainText().strip()
+
+
+class BatchEmitDialog(QDialog):
+    def __init__(self, orders, parent=None):
+        super().__init__(parent)
+        self.setWindowTitle("Emitir resultados en lote")
+        self.setMinimumSize(540, 480)
+        layout = QVBoxLayout(self)
+        description = QLabel(
+            "Seleccione las órdenes que desea incluir en el PDF."
+        )
+        description.setWordWrap(True)
+        layout.addWidget(description)
+        self.list_widget = QListWidget()
+        self.list_widget.setSelectionMode(QListWidget.NoSelection)
+        for order in orders:
+            display = order.get("display", "")
+            item = QListWidgetItem(display)
+            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
+            item.setCheckState(Qt.Checked if order.get("preselect") else Qt.Unchecked)
+            item.setData(Qt.UserRole, order.get("id"))
+            if order.get("emitted"):
+                item.setForeground(Qt.gray)
+            self.list_widget.addItem(item)
+        layout.addWidget(self.list_widget)
+        self.buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        self.buttons.accepted.connect(self.accept)
+        self.buttons.rejected.connect(self.reject)
+        layout.addWidget(self.buttons)
+
+    def get_selected_ids(self):
+        selected = []
+        for index in range(self.list_widget.count()):
+            item = self.list_widget.item(index)
+            if item.checkState() == Qt.Checked:
+                order_id = item.data(Qt.UserRole)
+                if order_id is not None:
+                    selected.append(int(order_id))
+        return selected
+
+
 class MainWindow(QMainWindow):
     def __init__(self, labdb, user):
         super().__init__()
         self.labdb = labdb
         self.user = user
         self.setWindowTitle(LAB_TITLE)
         # Configuración de ventana principal y menú lateral
         central_widget = QWidget()
         main_layout = QHBoxLayout(central_widget)
         side_menu_layout = QVBoxLayout()
         side_menu_widget = QWidget()
         side_menu_widget.setLayout(side_menu_layout)
         side_menu_widget.setFixedWidth(200)
         side_menu_widget.setStyleSheet("background-color: #2c3e50;")
         title_label = QLabel(LAB_TITLE)
         title_label.setStyleSheet("color: white; font-size: 16px; font-weight: bold;")
         title_label.setAlignment(Qt.AlignCenter)
         title_label.setWordWrap(True)
         side_menu_layout.addWidget(title_label)
         side_menu_layout.addSpacing(10)
         # Secciones/Páginas
         self.stack = QStackedWidget()
         self.current_order_context = None
         # Contenedor principal con cabecera y reloj
         content_widget = QWidget()
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1415,50 +1476,60 @@ class MainWindow(QMainWindow):
         try:
             height_val = float(height) if height else None
         except:
             height_val = None
         try:
             weight_val = float(weight) if weight else None
         except:
             weight_val = None
         sample_date = None
         if hasattr(self, 'sample_date_edit'):
             qdate = self.sample_date_edit.date()
             if isinstance(qdate, QDate) and qdate.isValid():
                 sample_date = qdate.toString("yyyy-MM-dd")
         if hasattr(self, 'sample_today_checkbox') and self.sample_today_checkbox.isChecked():
             sample_date = QDate.currentDate().toString("yyyy-MM-dd")
         # Insertar o actualizar paciente en BD
         patient_id = self.labdb.add_or_update_patient(doc_type, doc_number, first_name, last_name, birth_date, sex, origin, hcl, height_val, weight_val, bp)
         # Obtener lista de pruebas seleccionadas
         selected_tests = []
         for cb in self.page_registro.findChildren(QCheckBox):
             if cb.isChecked():
                 selected_tests.append(cb.text())
         if not selected_tests:
             QMessageBox.warning(self, "Sin pruebas", "Seleccione al menos una prueba.")
             return
+        duplicate_order = self.labdb.find_recent_duplicate_order(patient_id, selected_tests)
+        if duplicate_order:
+            reply = QMessageBox.question(
+                self,
+                "Posible duplicado",
+                f"Existe una orden reciente (#{duplicate_order}) con las mismas pruebas. ¿Desea continuar?",
+                QMessageBox.Yes | QMessageBox.No
+            )
+            if reply == QMessageBox.No:
+                return
         # Crear orden en BD con las pruebas seleccionadas
         order_id = self.labdb.add_order_with_tests(
             patient_id,
             selected_tests,
             self.user['id'],
             observations=observations,
             requested_by=requested_by_text,
             diagnosis=diagnosis,
             age_years=age_years,
             sample_date=sample_date
         )
         QMessageBox.information(self, "Registro exitoso", f"Paciente y pruebas registrados (Orden #{order_id}).")
         # Habilitar botón para ir a anotar resultados de esta orden
         btn_to_results.setEnabled(True)
         self.last_order_registered = order_id
         # Actualizar historial de solicitantes para próximas atenciones
         self.populate_requesters(keep_current=True)
     def clear_registration_form(self):
         # Limpiar todos los campos del formulario de registro
         self.input_doc_number.clear(); self.input_first_name.clear(); self.input_last_name.clear()
         self.input_birth_date.blockSignals(True)
         self.input_birth_date.setDate(QDate.currentDate())
         self.input_birth_date.blockSignals(False)
         self.input_age.clear()
         self.sex_male_radio.setChecked(True)
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1490,67 +1561,71 @@ class MainWindow(QMainWindow):
     def init_resultados_page(self):
         layout = QVBoxLayout(self.page_resultados)
         search_layout = QHBoxLayout()
         search_label = QLabel("Buscar:")
         self.order_search_input = QLineEdit()
         self.order_search_input.setPlaceholderText("Nombre, documento o # de orden")
         search_layout.addWidget(search_label)
         search_layout.addWidget(self.order_search_input, 1)
         sort_label = QLabel("Ordenar:")
         self.pending_sort_combo = QComboBox()
         self.pending_sort_combo.addItems([
             "Fecha (recientes primero)",
             "Fecha (antiguas primero)",
             "Número de orden (descendente)",
             "Número de orden (ascendente)"
         ])
         search_layout.addWidget(sort_label)
         search_layout.addWidget(self.pending_sort_combo)
         search_layout.addStretch()
         layout.addLayout(search_layout)
         top_layout = QHBoxLayout()
         lbl = QLabel("Orden pendiente:")
         self.combo_orders = QComboBox()
         self.combo_orders.setMinimumWidth(350)
         btn_load = QPushButton("Cargar")
+        btn_delete_order = QPushButton("Eliminar orden")
+        btn_delete_order.setStyleSheet("color: #c0392b;")
         top_layout.addWidget(lbl)
         top_layout.addWidget(self.combo_orders)
         top_layout.addWidget(btn_load)
+        top_layout.addWidget(btn_delete_order)
         layout.addLayout(top_layout)
         # Área scrollable para campos de resultados
         self.results_area = QScrollArea()
         self.results_area.setWidgetResizable(True)
         self.results_container = QWidget()
         self.results_layout = QVBoxLayout(self.results_container)
         self.results_layout.setContentsMargins(10, 10, 10, 10)
         self.results_layout.setSpacing(14)
         self.results_area.setWidget(self.results_container)
         layout.addWidget(self.results_area)
         btn_save = QPushButton("Guardar Resultados")
         layout.addWidget(btn_save)
         btn_load.clicked.connect(self.load_order_fields)
         btn_save.clicked.connect(self.save_results)
+        btn_delete_order.clicked.connect(self.delete_order_from_results)
         self.order_search_input.textChanged.connect(self.filter_pending_orders)
         self.pending_sort_combo.currentIndexChanged.connect(
             lambda: self.filter_pending_orders(self.order_search_input.text(), prefer_order=self.selected_order_id)
         )
     def populate_pending_orders(self):
         # Llenar combo de órdenes pendientes (no completadas)
         pending = self.labdb.get_pending_orders()
         self.pending_orders_cache = []
         for row in pending:
             oid, first, last, date, doc_type, doc_number = row
             self.pending_orders_cache.append({
                 "id": oid,
                 "first_name": (first or "").upper(),
                 "last_name": (last or "").upper(),
                 "date": date,
                 "doc_type": doc_type or "",
                 "doc_number": doc_number or ""
             })
         search_text = self.order_search_input.text() if hasattr(self, 'order_search_input') else ""
         prefer_id = self.selected_order_id or self.last_order_registered
         self.filter_pending_orders(search_text, prefer_order=prefer_id)
     def filter_pending_orders(self, text="", prefer_order=None):
         if not hasattr(self, 'combo_orders'):
             return
         filter_text = (text or "").strip().lower()
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1789,99 +1864,133 @@ class MainWindow(QMainWindow):
         self.results_layout.addStretch()
 
     def _should_auto_calculate_hb(self, order_test_names):
         valid_names = [name for name in order_test_names if name]
         return valid_names.count("Hematocrito") == 1 and len(valid_names) == 1
 
     def _prompt_remove_test(self, test_name):
         if not self.selected_order_id:
             return
         reply = QMessageBox.question(
             self,
             "Quitar examen",
             f"¿Desea quitar la prueba '{test_name}' de la orden seleccionada?",
             QMessageBox.Yes | QMessageBox.No
         )
         if reply == QMessageBox.No:
             return
         removed = self.labdb.remove_test_from_order(self.selected_order_id, test_name)
         if removed:
             QMessageBox.information(self, "Prueba eliminada", f"Se quitó '{test_name}' de la orden.")
             self.populate_pending_orders()
             self.populate_completed_orders()
             self.load_order_fields()
         else:
             QMessageBox.warning(self, "Acción no realizada", "No se pudo quitar la prueba seleccionada.")
+
     def save_results(self):
         # Guardar los resultados ingresados para la orden seleccionada
         if not self.selected_order_id:
             return
-        results_dict = {}
+        results_payload = {}
         has_empty = False
+        pending_samples = 0
+        missing_notes = []
         for test_name, info in self.order_fields.items():
             template = info.get("template")
+            meta = info.get("meta", {})
+            status_combo = meta.get("status_widget")
+            issue_widget = meta.get("issue_widget")
+            observation_widget = meta.get("observation_widget")
+            status_value = "recibida"
+            if status_combo:
+                status_value = status_combo.currentText().strip().lower() or "recibida"
+            issue_value = issue_widget.text().strip() if issue_widget else ""
+            observation_value = observation_widget.toPlainText().strip() if observation_widget else ""
+            if status_value == "pendiente":
+                pending_samples += 1
+            if status_value in {"pendiente", "rechazada"} and not issue_value:
+                missing_notes.append(test_name)
             if template:
                 values = {}
                 for key, field_info in info["fields"].items():
                     value = self._get_widget_value(field_info)
                     values[key] = value
-                    if value == "" and not field_info["definition"].get("optional", False):
+                    if status_value == "recibida" and value == "" and not field_info["definition"].get("optional", False):
                         has_empty = True
-                results_dict[test_name] = {
+                result_value = {
                     "type": "structured",
                     "template": info.get("template_name", test_name),
                     "values": values
                 }
             else:
                 field_info = info["fields"].get("__value__")
                 value = self._get_widget_value(field_info)
-                results_dict[test_name] = value
-                if value == "":
+                if status_value == "recibida" and value == "":
                     has_empty = True
+                result_value = value
+            results_payload[test_name] = {
+                "result": result_value,
+                "sample_status": status_value,
+                "sample_issue": issue_value,
+                "observation": observation_value
+            }
+        if missing_notes:
+            detalle = ", ".join(missing_notes)
+            QMessageBox.warning(
+                self,
+                "Motivo requerido",
+                f"Indique el motivo o detalle para las muestras marcadas como pendientes/rechazadas: {detalle}"
+            )
+            return
         if has_empty:
             reply = QMessageBox.question(
                 self,
                 "Confirmar",
                 "Hay pruebas o campos sin resultado. ¿Guardar de todos modos?",
                 QMessageBox.Yes | QMessageBox.No
             )
             if reply == QMessageBox.No:
                 return
-        completed = self.labdb.save_results(self.selected_order_id, results_dict)
+        completed = self.labdb.save_results(self.selected_order_id, results_payload)
         if completed:
             QMessageBox.information(self, "Completado", "Resultados guardados. Orden marcada como completada.")
             self.selected_order_id = None
             self.populate_pending_orders()
             self._clear_results_layout()
             msg = QLabel("Seleccione otra orden pendiente para continuar con la digitación de resultados.")
             msg.setStyleSheet("color: #555; font-style: italic;")
             msg.setWordWrap(True)
             self.results_layout.addWidget(msg)
             self.results_layout.addStretch()
         else:
-            QMessageBox.information(self, "Guardado", "Resultados guardados (orden aún incompleta).")
+            message = "Resultados guardados (orden aún incompleta)."
+            if pending_samples:
+                message += "\nHay muestras pendientes o rechazadas registradas."
+            QMessageBox.information(self, "Guardado", message)
             self.load_order_fields()
+
     def _clear_results_layout(self):
         if not hasattr(self, 'results_layout'):
             return
         self.current_order_context = None
         while self.results_layout.count():
             item = self.results_layout.takeAt(0)
             widget = item.widget()
             if widget:
                 widget.deleteLater()
     def _create_structured_field(self, field_def, existing_values, context=None):
         key = field_def.get("key")
         value = ""
         if key:
             value = existing_values.get(key, "")
         container = QWidget()
         layout = QHBoxLayout(container)
         layout.setContentsMargins(0, 0, 0, 0)
         layout.setSpacing(6)
         widget_info = {"key": key, "container": container}
         field_type = field_def.get("type", "text")
         if field_type == "choice":
             combo = QComboBox()
             combo.addItems(field_def.get("choices", []))
             if value:
                 idx = combo.findText(value)
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2484,50 +2593,59 @@ class MainWindow(QMainWindow):
         hcl_value = clean(entry.get("hcl")) or "—"
         hcl_line = f"HCL: {hcl_value}"
         return "\n".join([name_line or "—", doc_line, birth_line, hcl_line])
 
     def _format_date_for_registry(self, entry):
         sample = entry.get("sample_date_raw")
         if sample:
             formatted = self._format_short_date(sample)
             if formatted:
                 return formatted
         raw_date = entry.get("order_date_raw") or entry.get("date")
         return self._format_short_date(raw_date)
 
     def _format_emission_status(self, emitted_flag, emitted_at):
         if emitted_flag:
             if emitted_at:
                 try:
                     parsed = datetime.datetime.strptime(emitted_at, "%Y-%m-%d %H:%M:%S")
                     return f"Sí ({parsed.strftime('%d/%m/%Y')})"
                 except Exception:
                     return "Sí"
             return "Sí"
         if emitted_flag == 0:
             return "No"
         return "-"
+
+    def _format_sample_status_text(self, status_value, note):
+        value = (status_value or "recibida").strip().lower()
+        if value == "recibida":
+            return ""
+        label = "Pendiente" if value == "pendiente" else "Rechazada"
+        if note:
+            return f"{label} - {note}"
+        return label
     def _calculate_age_years(self, patient_info, order_info):
         age_value = order_info.get('age_years') if isinstance(order_info, dict) else None
         if age_value is not None:
             try:
                 return int(age_value)
             except (TypeError, ValueError):
                 age_value = None
         if age_value is None:
             birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     age_value = bd.daysTo(QDate.currentDate()) // 365
         return age_value
     def _format_age_text(self, patient_info, order_info):
         age_value = self._calculate_age_years(patient_info, order_info)
         return f"{age_value} años" if age_value is not None else "-"
 
     def _get_field_reference(self, field_def, context=None):
         if not field_def:
             return None
         reference = field_def.get("reference")
         if not reference:
             return reference
         effective_context = context or self.current_order_context
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2704,232 +2822,335 @@ class MainWindow(QMainWindow):
             f"{position}_logo.png",
             f"{position}_logo.jpg",
         ]
         if position == "center":
             base_names.extend([
                 "logo.png",
                 "logo_central.png",
                 "logo_central.jpg",
                 "logo_centro.png",
             ])
         if position == "right":
             base_names.extend(["logo_secondary.png", "logo_secundario.png"])
         for directory in search_dirs:
             for name in base_names:
                 candidate = os.path.join(directory, name) if directory else name
                 if os.path.exists(candidate):
                     return candidate
         return None
     def init_emitir_page(self):
         layout = QVBoxLayout(self.page_emitir)
         top_layout = QHBoxLayout()
         lbl = QLabel("Orden completada:")
         self.combo_completed = QComboBox()
         btn_view = QPushButton("Ver")
         btn_add_tests = QPushButton("Agregar pruebas")
+        btn_delete_completed = QPushButton("Eliminar orden")
+        btn_delete_completed.setStyleSheet("color: #c0392b;")
         top_layout.addWidget(lbl)
         top_layout.addWidget(self.combo_completed, 1)
         top_layout.addWidget(btn_view)
         top_layout.addWidget(btn_add_tests)
+        top_layout.addWidget(btn_delete_completed)
         layout.addLayout(top_layout)
         sort_layout = QHBoxLayout()
         self.include_emitted_checkbox = QCheckBox("Mostrar emitidos")
         sort_layout.addWidget(self.include_emitted_checkbox)
         sort_layout.addStretch()
         sort_label = QLabel("Ordenar:")
         self.completed_sort_combo = QComboBox()
         self.completed_sort_combo.addItems([
             "Fecha (recientes primero)",
             "Fecha (antiguas primero)",
             "Número de orden (descendente)",
             "Número de orden (ascendente)"
         ])
         sort_layout.addWidget(sort_label)
         sort_layout.addWidget(self.completed_sort_combo)
         layout.addLayout(sort_layout)
         self.output_text = QTextEdit(); self.output_text.setReadOnly(True)
         layout.addWidget(self.output_text)
         btn_pdf = QPushButton("Emitir en PDF"); btn_excel = QPushButton("Exportar a Excel")
-        btns_layout = QHBoxLayout(); btns_layout.addWidget(btn_pdf); btns_layout.addWidget(btn_excel)
+        btn_pdf_batch = QPushButton("Emitir PDF en lote")
+        btns_layout = QHBoxLayout(); btns_layout.addWidget(btn_pdf); btns_layout.addWidget(btn_pdf_batch); btns_layout.addWidget(btn_excel)
         layout.addLayout(btns_layout)
         btn_view.clicked.connect(self.display_selected_result)
         btn_pdf.clicked.connect(self.export_pdf)
         btn_excel.clicked.connect(self.export_excel)
+        btn_pdf_batch.clicked.connect(self.export_pdf_batch)
         btn_add_tests.clicked.connect(self.add_tests_to_selected_order)
+        btn_delete_completed.clicked.connect(self.delete_order_from_emission)
         self.include_emitted_checkbox.toggled.connect(self.populate_completed_orders)
         self.completed_sort_combo.currentIndexChanged.connect(lambda: self._refresh_completed_combo())
     def populate_completed_orders(self):
         # Llenar combo de órdenes completadas
         include_emitted = False
         if hasattr(self, 'include_emitted_checkbox'):
             include_emitted = self.include_emitted_checkbox.isChecked()
         completed_rows = self.labdb.get_completed_orders(include_emitted=include_emitted)
         self.completed_orders_cache = []
         for row in completed_rows:
             oid, first, last, date, doc_type, doc_number, emitted, emitted_at = row
             order = {
                 "id": oid,
                 "first_name": (first or "").upper(),
                 "last_name": (last or "").upper(),
                 "date": date,
                 "doc_type": doc_type or "",
                 "doc_number": doc_number or "",
                 "emitted": bool(emitted),
                 "emitted_at": emitted_at
             }
             self.completed_orders_cache.append(order)
         self._refresh_completed_combo()
 
+
+def delete_order_from_results(self):
+    if not hasattr(self, 'combo_orders'):
+        return
+    data = self.combo_orders.currentData()
+    if data is None:
+        QMessageBox.information(self, "Sin selección", "Seleccione una orden pendiente para eliminar.")
+        return
+    self._confirm_delete_order(int(data))
+
+def delete_order_from_emission(self):
+    if not hasattr(self, 'combo_completed'):
+        return
+    data = self.combo_completed.currentData()
+    if data is None:
+        QMessageBox.information(self, "Sin selección", "Seleccione una orden completada para eliminar.")
+        return
+    self._confirm_delete_order(int(data))
+
+def _confirm_delete_order(self, order_id):
+    if not order_id:
+        return
+    info = self.labdb.get_order_details(order_id)
+    if not info:
+        QMessageBox.warning(self, "Orden no disponible", "La orden seleccionada ya no está disponible.")
+        self.populate_pending_orders()
+        self.populate_completed_orders()
+        return
+    pat = info.get("patient", {})
+    ord_inf = info.get("order", {})
+    patient_name = pat.get("name") or "-"
+    confirm = QMessageBox.question(
+        self,
+        "Eliminar orden",
+        f"¿Desea eliminar la orden #{order_id} asociada a {patient_name}?",
+        QMessageBox.Yes | QMessageBox.No
+    )
+    if confirm == QMessageBox.No:
+        return
+    dialog = ReasonDialog(
+        "Motivo de eliminación",
+        "Indique el motivo por el que se elimina la orden.",
+        self,
+        placeholder="Motivo (ej. duplicado, prueba, error de digitación)"
+    )
+    dialog.text_edit.setPlainText("Duplicidad de registro")
+    if dialog.exec_() != QDialog.Accepted:
+        return
+    reason = dialog.get_reason() or "Sin motivo"
+    deleted = self.labdb.mark_order_deleted(order_id, reason, self.user.get('id'))
+    if deleted:
+        QMessageBox.information(self, "Orden eliminada", f"La orden #{order_id} fue eliminada correctamente.")
+        if getattr(self, 'selected_order_id', None) == order_id:
+            self.selected_order_id = None
+        self.populate_pending_orders()
+        self.populate_completed_orders()
+        self.load_activity_summary()
+        self.output_text.clear()
+        self._clear_results_layout()
+    else:
+        QMessageBox.warning(self, "Sin cambios", "No se pudo eliminar la orden seleccionada.")
+
     def add_tests_to_selected_order(self):
         data = self.combo_completed.currentData() if hasattr(self, 'combo_completed') else None
         if data is None:
             QMessageBox.information(self, "Sin selección", "Seleccione una orden para agregar pruebas adicionales.")
             return
         order_id = int(data)
         all_tests = self.labdb.get_all_tests()
         existing = self.labdb.get_tests_for_order(order_id)
         dialog = AddTestsDialog(all_tests, existing, self)
         if dialog.exec_() != QDialog.Accepted:
             return
         selected = dialog.get_selected_tests()
         if not selected:
             QMessageBox.information(self, "Sin cambios", "No se seleccionaron nuevas pruebas.")
             return
         added = self.labdb.add_tests_to_order(order_id, selected)
         if not added:
             QMessageBox.information(self, "Sin cambios", "Las pruebas seleccionadas ya estaban asociadas a la orden.")
             return
         QMessageBox.information(
             self,
             "Pruebas agregadas",
             "Se agregaron {0} prueba(s). Registre los resultados antes de emitir nuevamente.".format(len(added))
         )
         self.selected_order_id = order_id
         self.populate_pending_orders()
         self.populate_completed_orders()
         reply = QMessageBox.question(
             self,
             "Registrar resultados",
             "¿Desea ir a la pantalla de resultados para completar las nuevas pruebas?",
             QMessageBox.Yes | QMessageBox.No
         )
         if reply == QMessageBox.Yes:
             self.stack.setCurrentWidget(self.page_resultados)
             if hasattr(self, 'combo_orders'):
                 self._select_order_in_combo(self.combo_orders, order_id)
             self.load_order_fields()
+
     def display_selected_result(self):
         # Mostrar los resultados de la orden seleccionada en el cuadro de texto
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
             return
-        pat = info["patient"]; ord_inf = info["order"]; results = info["results"]
+        pat = info["patient"]
+        ord_inf = info["order"]
+        results = info["results"]
         context = {"patient": pat, "order": ord_inf}
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
         lines = [f"PACIENTE: {pat.get('name') or '-'}", f"DOCUMENTO: {doc_text}"]
         age_value = self._calculate_age_years(pat, ord_inf)
         lines.append(f"EDAD: {age_value} AÑOS" if age_value is not None else "EDAD: -")
         lines.append(f"SEXO: {pat.get('sex') or '-'}")
         lines.append(f"HISTORIA CLÍNICA: {pat.get('hcl') or '-'}")
         lines.append(f"PROCEDENCIA: {pat.get('origin') or '-'}")
-        lines.append(f"FECHA DE MUESTRA: {ord_inf.get('date') or '-'}")
-        lines.append(f"SOLICITANTE: {ord_inf.get('requested_by') or '-'}")
-        lines.append(f"DIAGNÓSTICO PRESUNTIVO: {ord_inf.get('diagnosis') or '-'}")
+        requester = ord_inf.get('requested_by') or '-'
+        lines.append(f"SOLICITANTE: {requester}")
         emission_raw = ord_inf.get('emitted_at')
         if emission_raw:
             try:
                 emission_dt = datetime.datetime.strptime(emission_raw, "%Y-%m-%d %H:%M:%S")
                 emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 emission_display = emission_raw
         else:
             emission_display = "Pendiente de emisión"
-        lines.append(f"FECHA DE EMISIÓN: {emission_display}")
+        lines.append(f"FECHA DEL INFORME: {emission_display}")
+        lines.append(f"FECHA DE REGISTRO: {ord_inf.get('date') or '-'}")
         lines.append("RESULTADOS:")
-        for test_name, result, _ in results:
-            formatted_lines = self._format_result_lines(test_name, result, context=context)
+        for test_name, raw_result, _, sample_status, sample_issue, observation, _ in results:
+            formatted_lines = self._format_result_lines(test_name, raw_result, context=context)
             if formatted_lines:
                 lines.extend(formatted_lines)
+            status_text = self._format_sample_status_text(sample_status, sample_issue)
+            if status_text:
+                lines.append(f"    Estado de muestra: {status_text}")
+            if observation:
+                lines.append(f"    Observación: {observation}")
         if ord_inf["observations"]:
-            lines.append(f"Observaciones: {ord_inf['observations']}")
+            lines.append(f"Observaciones generales: {ord_inf['observations']}")
         self.output_text.setPlainText("\n".join(lines))
 
+
     def export_pdf(self):
-        # Exportar el resultado seleccionado a un archivo PDF
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
+            QMessageBox.warning(self, "Orden no disponible", "La orden seleccionada ya no está disponible.")
+            self.populate_completed_orders()
             return
-        pat = info["patient"]; ord_inf = info["order"]; results = info["results"]
+        ord_inf = info["order"]
         suggested_name = f"Orden_{order_id}.pdf"
         options = QFileDialog.Options()
         file_path, _ = QFileDialog.getSaveFileName(self, "Guardar PDF", suggested_name, "Archivos PDF (*.pdf)", options=options)
         if not file_path:
             return
         if not file_path.lower().endswith(".pdf"):
             file_path += ".pdf"
-        existing_emission = ord_inf.get('emitted_at')
-        mark_as_emitted = not (ord_inf.get('emitted') and existing_emission)
-        if mark_as_emitted:
-            emission_time = datetime.datetime.now()
-            emission_display = emission_time.strftime("%d/%m/%Y %H:%M")
-            emission_timestamp = emission_time.strftime("%Y-%m-%d %H:%M:%S")
-        else:
-            emission_timestamp = existing_emission
+        existing_emission = ord_inf.get('emitted') and ord_inf.get('emitted_at')
+        mark_as_emitted = False
+        if existing_emission:
+            reply = QMessageBox.question(
+                self,
+                "Emitido previamente",
+                "El informe ya fue emitido anteriormente. ¿Desea generar una copia?",
+                QMessageBox.Yes | QMessageBox.No
+            )
+            if reply == QMessageBox.No:
+                return
+            emission_timestamp = ord_inf.get('emitted_at')
             try:
-                parsed = datetime.datetime.strptime(existing_emission, "%Y-%m-%d %H:%M:%S")
-                emission_display = parsed.strftime("%d/%m/%Y %H:%M")
+                emission_dt = datetime.datetime.strptime(emission_timestamp, "%Y-%m-%d %H:%M:%S")
+                emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
-                emission_display = existing_emission or "-"
+                emission_display = emission_timestamp or "-"
+        else:
+            mark_as_emitted = True
+            emission_time = datetime.datetime.now()
+            emission_timestamp = emission_time.strftime("%Y-%m-%d %H:%M:%S")
+            emission_display = emission_time.strftime("%d/%m/%Y %H:%M")
+        pdf = FPDF('P', 'mm', 'A4')
+        pdf.set_margins(12, 12, 12)
+        pdf.set_auto_page_break(True, margin=14)
+        pdf.add_page()
+        self._render_order_pdf(pdf, info, emission_display)
+        try:
+            pdf.output(file_path)
+        except Exception as exc:
+            QMessageBox.warning(self, "Error", f"No se pudo guardar el PDF:\n{exc}")
+            return
+        if mark_as_emitted:
+            self.labdb.mark_order_emitted(order_id, emission_timestamp)
+        QMessageBox.information(self, "Informe emitido", f"Reporte guardado en:\n{file_path}")
+        self.populate_completed_orders()
+        self.output_text.clear()
+
+    def _render_order_pdf(self, pdf, info, emission_display):
+        pat = info["patient"]
+        ord_inf = info["order"]
+        results = info["results"]
+        context = {"patient": pat, "order": ord_inf}
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
         patient_name = (pat.get('name') or '-').upper()
         age_text = self._format_age_text(pat, ord_inf)
         order_date_text = ord_inf.get('date') or "-"
         sex_text = (pat.get('sex') or '-').upper()
         hcl_text = (pat.get('hcl') or '-').upper()
         origin_text = (pat.get('origin') or '-').upper()
         requester_text = (ord_inf.get('requested_by') or '-').upper()
-        diagnosis_text = (ord_inf.get('diagnosis') or '-').upper()
-        context = {"patient": pat, "order": ord_inf}
-        pdf = FPDF('P', 'mm', 'A4')
-        pdf.set_margins(12, 12, 12)
-        pdf.set_auto_page_break(True, margin=14)
-        pdf.add_page()
+        emission_state = "Emitido" if emission_display != "Pendiente de emisión" else "Por emitir"
         header_image_path = os.path.join("img", "img.png")
         info_pairs = [
             (("Paciente", patient_name), ("Edad", age_text)),
             (("Documento", doc_text.upper() if doc_text else "-"), ("Sexo", sex_text)),
-            (("Historia clínica", hcl_text), ("Fecha emisión", emission_display)),
-            (("Procedencia", origin_text), ("Fecha muestra", order_date_text)),
-            (("Solicitante", requester_text), ("Diagnóstico presuntivo", diagnosis_text)),
+            (("Historia clínica", hcl_text), ("Estado de emisión", emission_state)),
+            (("Procedencia", origin_text), ("Fecha del informe", emission_display)),
+            (("Solicitante", requester_text), ("Fecha de registro", order_date_text)),
         ]
 
         def draw_patient_info():
             col_width = (pdf.w - pdf.l_margin - pdf.r_margin) / 2
 
             def wrap_value_lines(text, width):
                 safe_value = str(text) if text not in (None, "") else "-"
                 safe_value = self._ensure_latin1(safe_value)
                 segments = []
                 for part in safe_value.split('\n'):
                     part = part.strip()
                     if part:
                         segments.append(part)
                 if not segments:
                     segments = [safe_value.strip() or "-"]
                 lines = []
                 for segment in segments:
                     words = segment.split()
                     if not words:
                         lines.append("-")
                         continue
                     current = words[0]
                     for word in words[1:]:
                         candidate = f"{current} {word}"
                         if pdf.get_string_width(candidate) <= max(width, 1):
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3001,322 +3222,420 @@ class MainWindow(QMainWindow):
                 return True
             return False
 
         def wrap_text(text, max_width):
             if max_width <= 0:
                 return [str(text)]
             if text in (None, ""):
                 text = "-"
             text = self._ensure_latin1(str(text)).replace('\r', ' ')
             segments = []
             for part in text.split('\n'):
                 stripped = part.strip()
                 if stripped:
                     segments.append(stripped)
             if not segments:
                 segments = [text.strip() or "-"]
             lines = []
             for segment in segments:
                 words = segment.split()
                 if not words:
                     lines.append("-")
                     continue
                 current = words[0]
                 for word in words[1:]:
                     candidate = f"{current} {word}"
-                    if pdf.get_string_width(candidate) <= max_width:
+                    if pdf.get_string_width(candidate) <= max(max_width, 1):
                         current = candidate
                     else:
                         lines.append(current)
                         current = word
                 lines.append(current)
             return lines or ["-"]
 
         def render_table_header(widths, on_new_page=None):
             header_height = 6
             if ensure_space(header_height) and on_new_page:
                 on_new_page()
                 ensure_space(header_height)
             pdf.set_font("Arial", 'B', 7.2)
             pdf.set_text_color(255, 255, 255)
             pdf.set_fill_color(46, 117, 182)
             x_start = pdf.l_margin
             pdf.set_x(x_start)
             headers = ["Parámetro", "Resultado", "Valores de referencia"]
             for idx, title in enumerate(headers):
                 pdf.cell(widths[idx], header_height, self._ensure_latin1(title), border=1, align='C', fill=True)
             pdf.ln(header_height)
             pdf.set_text_color(0, 0, 0)
 
         def render_table_row(texts, widths, on_new_page):
             line_height = 3.4
             padding_x = 1.4
             padding_y = 0.9
             pdf.set_font("Arial", '', 6.8)
             lines_by_cell = []
             max_lines = 1
             for idx, text in enumerate(texts):
                 available = max(widths[idx] - 2 * padding_x, 1)
                 lines = wrap_text(text, available)
                 lines_by_cell.append(lines)
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             row_height = max_lines * line_height + 2 * padding_y
             if ensure_space(row_height):
                 on_new_page()
-                render_table_header(widths)
+                render_table_header(widths, on_new_page)
             x_start = pdf.l_margin
             y_start = pdf.get_y()
             pdf.set_draw_color(210, 215, 226)
             pdf.set_line_width(0.2)
             for idx, lines in enumerate(lines_by_cell):
                 cell_width = widths[idx]
                 x_pos = x_start + sum(widths[:idx])
                 pdf.set_fill_color(255, 255, 255)
                 pdf.rect(x_pos, y_start, cell_width, row_height)
                 text_y = y_start + padding_y
                 for line in lines:
                     line = self._ensure_latin1(line)
                     pdf.set_xy(x_pos + padding_x, text_y)
                     pdf.cell(cell_width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
             pdf.set_xy(pdf.l_margin, y_start + row_height)
 
         def render_section_row(label, total_width, widths, on_new_page):
             section_height = 4.2
             if ensure_space(section_height + 1):
                 on_new_page()
-                render_table_header(widths)
+                render_table_header(widths, on_new_page)
             pdf.set_font("Arial", 'B', 6.8)
             pdf.set_fill_color(242, 246, 253)
             pdf.set_text_color(47, 84, 150)
             pdf.cell(total_width, section_height, self._ensure_latin1(label), border=1, ln=1, align='L', fill=True)
             pdf.set_text_color(0, 0, 0)
 
         draw_page_header()
 
         table_total_width = pdf.w - pdf.l_margin - pdf.r_margin
         column_widths = [table_total_width * 0.38, table_total_width * 0.27, table_total_width * 0.35]
 
         def draw_test_header(title):
             ensure_space(9)
             pdf.set_font("Arial", 'B', 8.6)
             pdf.set_text_color(255, 255, 255)
             pdf.set_fill_color(46, 117, 182)
             pdf.cell(0, 6, self._ensure_latin1(title.upper()), ln=1, fill=True)
             pdf.set_text_color(0, 0, 0)
             pdf.ln(1.2)
 
-        for test_name, raw_result, _ in results:
+        for test_name, raw_result, _, sample_status, sample_issue, observation, _ in results:
             structure = self._extract_result_structure(test_name, raw_result, context=context)
             if structure.get("type") == "structured":
                 items = structure.get("items", [])
                 if not any(item.get("type") == "value" for item in items):
                     continue
             else:
                 value_text = structure.get("value", "")
                 if isinstance(value_text, str):
                     if value_text.strip() == "":
                         continue
                 elif self._is_blank_result(value_text):
                     continue
             draw_test_header(test_name)
 
             def on_new_page():
                 draw_test_header(test_name)
 
             if structure.get("type") == "structured":
                 render_table_header(column_widths, on_new_page)
                 for item in structure.get("items", []):
                     if item.get("type") == "section":
                         render_section_row(item.get("label", ""), sum(column_widths), column_widths, on_new_page)
                         continue
                     row_texts = [
                         item.get('label', ''),
                         item.get('value', '-'),
                         item.get('reference') or '-'
                     ]
                     render_table_row(row_texts, column_widths, on_new_page)
             else:
                 text_value = structure.get("value", "")
                 ensure_space(6)
                 pdf.set_font("Arial", '', 7)
                 pdf.multi_cell(0, 4, self._ensure_latin1(text_value))
+            status_text = self._format_sample_status_text(sample_status, sample_issue)
+            if status_text:
+                ensure_space(5)
+                pdf.set_font("Arial", 'I', 6.6)
+                pdf.set_text_color(166, 38, 38)
+                pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Estado de muestra: {status_text}"))
+                pdf.set_text_color(0, 0, 0)
+            if observation:
+                ensure_space(5)
+                pdf.set_font("Arial", 'I', 6.6)
+                pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Observación: {observation}"))
             pdf.ln(2)
 
-        if ord_inf.get('observations'):
+        if ord_inf.get('observations') and str(ord_inf['observations']).strip().upper() not in {"", "N/A"}:
             ensure_space(8)
             pdf.set_font("Arial", 'B', 7.4)
-            pdf.cell(0, 4.2, "Observaciones", ln=1)
+            pdf.cell(0, 4.2, "Observaciones generales", ln=1)
             pdf.set_font("Arial", '', 6.9)
             pdf.multi_cell(0, 3.6, self._ensure_latin1(ord_inf['observations']))
             pdf.ln(1.5)
 
+    def export_pdf_batch(self):
+        orders = getattr(self, 'completed_orders_cache', [])
+        if not orders:
+            QMessageBox.information(self, "Sin órdenes", "No hay órdenes completadas para emitir.")
+            return
+        options = []
+        for order in orders:
+            option = {
+                "id": order["id"],
+                "display": self._format_order_display(order),
+                "preselect": not order.get("emitted"),
+                "emitted": order.get("emitted")
+            }
+            options.append(option)
+        dialog = BatchEmitDialog(options, self)
+        if dialog.exec_() != QDialog.Accepted:
+            return
+        selected_ids = dialog.get_selected_ids()
+        if not selected_ids:
+            QMessageBox.information(self, "Sin selección", "Seleccione al menos una orden para emitir.")
+            return
+        orders_to_emit = []
+        already_emitted = []
+        for oid in selected_ids:
+            info = self.labdb.get_order_details(oid)
+            if not info:
+                continue
+            ord_inf = info["order"]
+            existing_emission = ord_inf.get('emitted') and ord_inf.get('emitted_at')
+            if existing_emission:
+                already_emitted.append(oid)
+                emission_timestamp = ord_inf.get('emitted_at')
+                try:
+                    emission_dt = datetime.datetime.strptime(emission_timestamp, "%Y-%m-%d %H:%M:%S")
+                    emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
+                except Exception:
+                    emission_display = emission_timestamp or "-"
+                mark = False
+            else:
+                emission_time = datetime.datetime.now()
+                emission_timestamp = emission_time.strftime("%Y-%m-%d %H:%M:%S")
+                emission_display = emission_time.strftime("%d/%m/%Y %H:%M")
+                mark = True
+            orders_to_emit.append({
+                "id": oid,
+                "info": info,
+                "emission_display": emission_display,
+                "emission_timestamp": emission_timestamp,
+                "mark": mark
+            })
+        if not orders_to_emit:
+            QMessageBox.information(self, "Sin datos", "Las órdenes seleccionadas no están disponibles para emitir.")
+            return
+        if already_emitted:
+            reply = QMessageBox.question(
+                self,
+                "Emitir copias",
+                "Algunas órdenes ya fueron emitidas. ¿Desea generar copias junto con los nuevos informes?",
+                QMessageBox.Yes | QMessageBox.No
+            )
+            if reply == QMessageBox.No:
+                orders_to_emit = [entry for entry in orders_to_emit if entry.get("mark")]
+                if not orders_to_emit:
+                    return
+        file_path, _ = QFileDialog.getSaveFileName(
+            self,
+            "Guardar lote",
+            "Resultados_lote.pdf",
+            "Archivos PDF (*.pdf)"
+        )
+        if not file_path:
+            return
+        if not file_path.lower().endswith(".pdf"):
+            file_path += ".pdf"
+        pdf = FPDF('P', 'mm', 'A4')
+        pdf.set_margins(12, 12, 12)
+        pdf.set_auto_page_break(True, margin=14)
+        for idx, entry in enumerate(orders_to_emit):
+            pdf.add_page()
+            self._render_order_pdf(pdf, entry["info"], entry["emission_display"])
         try:
             pdf.output(file_path)
-        except Exception as e:
-            QMessageBox.warning(self, "Error", f"No se pudo guardar el PDF:\n{e}")
+        except Exception as exc:
+            QMessageBox.warning(self, "Error", f"No se pudo guardar el PDF:\n{exc}")
             return
-        if mark_as_emitted:
-            self.labdb.mark_order_emitted(order_id, emission_timestamp)
-        QMessageBox.information(self, "Informe emitido", f"Reporte guardado en:\n{file_path}")
+        for entry in orders_to_emit:
+            if entry.get("mark"):
+                self.labdb.mark_order_emitted(entry["id"], entry["emission_timestamp"])
+        QMessageBox.information(self, "Informe emitido", f"Resultados guardados en:\n{file_path}")
         self.populate_completed_orders()
-        self.output_text.clear()
-
 
     def export_excel(self):
         # Exportar todos los resultados a un archivo CSV (Excel puede abrirlo)
         options = QFileDialog.Options()
         file_path, _ = QFileDialog.getSaveFileName(self, "Exportar datos", "", "Archivo CSV (*.csv)", options=options)
         if not file_path:
             return
         if not file_path.lower().endswith(".csv"):
             file_path += ".csv"
         self.labdb.cur.execute("""
             SELECT p.first_name, p.last_name, p.doc_type, p.doc_number, p.sex, p.birth_date,
-                   t.name, ot.result, o.date, o.requested_by, o.diagnosis, o.age_years
+                   t.name, ot.result, o.date, o.requested_by, ot.sample_status, ot.sample_issue, ot.observation, o.age_years
             FROM order_tests ot
             JOIN orders o ON ot.order_id = o.id
             JOIN patients p ON o.patient_id = p.id
             JOIN tests t ON ot.test_id = t.id
+            WHERE (o.deleted IS NULL OR o.deleted=0) AND (ot.deleted IS NULL OR ot.deleted=0)
         """)
         rows = self.labdb.cur.fetchall()
         try:
             with open(file_path, 'w', encoding='utf-8') as f:
-                f.write("Nombre,Apellidos,Documento,Prueba,Resultado,Fecha,Solicitante,Diagnostico presuntivo,Edad (años)\n")
-                for first, last, doc_type, doc_num, sex, birth_date, test_name, result, date, requester, diagnosis, age_years in rows:
+                f.write("Nombre,Apellidos,Documento,Prueba,Resultado,Fecha,Solicitante,Estado de muestra,Observación muestra,Edad (años)\n")
+                for first, last, doc_type, doc_num, sex, birth_date, test_name, result, date, requester, sample_status, sample_issue, observation, age_years in rows:
                     name = (first or "").upper(); surn = (last or "").upper(); doc = f"{doc_type} {doc_num}".strip()
                     context = {
                         "patient": {"sex": sex, "birth_date": birth_date},
                         "order": {"age_years": age_years}
                     }
                     res = self._format_result_for_export(test_name, result, context=context)
                     res = res.replace('"', "'")
                     dt = date
                     req = (requester or "").upper()
-                    diag = (diagnosis or "").upper()
+                    status_text = self._format_sample_status_text(sample_status, sample_issue) or "-"
+                    obs_text = (observation or "").strip().replace('"', "'")
                     age_txt = str(age_years) if age_years is not None else ""
-                    line = f"{name},{surn},{doc},{test_name},\"{res}\",{dt},{req},{diag},{age_txt}\n"
+                    line = f"{name},{surn},{doc},{test_name},\"{res}\",{dt},{req},{status_text},\"{obs_text}\",{age_txt}\n"
                     f.write(line)
             QMessageBox.information(self, "Exportado", f"Datos exportados a:\n{file_path}")
         except Exception as e:
             QMessageBox.warning(self, "Error", f"No se pudo exportar:\n{e}")
     def init_analisis_page(self):
         layout = QVBoxLayout(self.page_analisis)
         self.stats_label = QLabel()
         layout.addWidget(self.stats_label)
         self.stats_table = QTableWidget(0, 2)
         self.stats_table.setHorizontalHeaderLabels(["Categoría", "Cantidad"])
         layout.addWidget(self.stats_table)
         controls_layout = QHBoxLayout()
         controls_layout.addWidget(QLabel("Período:"))
         self.range_combo = QComboBox()
         self.range_combo.addItems([
             "Hoy",
             "Esta semana",
             "Este mes",
             "Últimos 30 días",
             "Rango personalizado"
         ])
         controls_layout.addWidget(self.range_combo)
         controls_layout.addSpacing(10)
         self.start_date_edit = QDateEdit(QDate.currentDate())
         self.start_date_edit.setDisplayFormat("dd-MM-yyyy")
         self.start_date_edit.setCalendarPopup(True)
         controls_layout.addWidget(QLabel("Desde:"))
         controls_layout.addWidget(self.start_date_edit)
         self.end_date_edit = QDateEdit(QDate.currentDate())
         self.end_date_edit.setDisplayFormat("dd-MM-yyyy")
         self.end_date_edit.setCalendarPopup(True)
         controls_layout.addWidget(QLabel("Hasta:"))
         controls_layout.addWidget(self.end_date_edit)
         controls_layout.addSpacing(10)
         self.view_activity_btn = QPushButton("Mostrar registro")
         self.export_activity_pdf_btn = QPushButton("Exportar PDF")
         self.export_activity_csv_btn = QPushButton("Exportar CSV")
+        self.delete_activity_btn = QPushButton("Eliminar selección")
+        self.delete_activity_btn.setStyleSheet("color: #c0392b;")
         controls_layout.addWidget(self.view_activity_btn)
         controls_layout.addWidget(self.export_activity_pdf_btn)
         controls_layout.addWidget(self.export_activity_csv_btn)
+        controls_layout.addWidget(self.delete_activity_btn)
         controls_layout.addStretch()
         layout.addLayout(controls_layout)
         self.activity_caption = QLabel()
         self.activity_caption.setStyleSheet("font-weight: bold;")
         layout.addWidget(self.activity_caption)
-        self.activity_table = QTableWidget(0, 7)
+        self.activity_table = QTableWidget(0, 8)
         self.activity_table.setHorizontalHeaderLabels([
             "Fecha",
             "Orden",
             "Paciente",
             "Documento",
             "Edad",
             "Prueba",
+            "Estado",
             "Resultado"
         ])
         self.activity_table.setAlternatingRowColors(True)
         self.activity_table.horizontalHeader().setStretchLastSection(True)
+        self.activity_table.setSelectionMode(QTableWidget.MultiSelection)
         layout.addWidget(self.activity_table)
         history_group = QGroupBox("Historial por DNI")
         history_layout = QVBoxLayout(history_group)
         history_search_layout = QHBoxLayout()
         history_search_layout.addWidget(QLabel("DNI:"))
         self.history_doc_input = QLineEdit()
         self.history_doc_input.setPlaceholderText("Ingrese DNI")
         history_search_layout.addWidget(self.history_doc_input)
         self.history_search_btn = QPushButton("Buscar")
         history_search_layout.addWidget(self.history_search_btn)
         self.history_open_btn = QPushButton("Ver en emisión")
         self.history_open_btn.setEnabled(False)
         history_search_layout.addWidget(self.history_open_btn)
         history_search_layout.addStretch()
         history_layout.addLayout(history_search_layout)
         history_headers = [
             "Fecha",
             "Orden",
             "Paciente",
             "Documento",
             "Edad",
             "Hematología",
             "Bioquímica",
             "Micro/Parasitología",
             "Otros exámenes",
             "Emitido"
         ]
         self.history_table = QTableWidget(0, len(history_headers))
         self.history_table.setHorizontalHeaderLabels(history_headers)
         self.history_table.setSelectionBehavior(QTableWidget.SelectRows)
         self.history_table.setSelectionMode(QTableWidget.SingleSelection)
         self.history_table.setAlternatingRowColors(True)
         self.history_table.setWordWrap(True)
         self.history_table.verticalHeader().setVisible(False)
         self.history_table.horizontalHeader().setStretchLastSection(True)
         history_layout.addWidget(self.history_table)
         layout.addWidget(history_group)
         self._history_results = []
         self.range_combo.currentIndexChanged.connect(self._update_range_controls)
         self.view_activity_btn.clicked.connect(self.load_activity_summary)
         self.export_activity_pdf_btn.clicked.connect(lambda: self.export_activity_record("pdf"))
         self.export_activity_csv_btn.clicked.connect(lambda: self.export_activity_record("csv"))
+        self.delete_activity_btn.clicked.connect(self.delete_selected_activity_entries)
         self._update_range_controls()
         self.history_doc_input.returnPressed.connect(self.search_patient_history)
         self.history_search_btn.clicked.connect(self.search_patient_history)
         self.history_open_btn.clicked.connect(self.open_history_order_from_analysis)
         self.history_table.itemSelectionChanged.connect(self._on_history_selection_changed)
     def refresh_statistics(self):
         stats = self.labdb.get_statistics()
         text = (f"Pacientes registrados: {stats['total_patients']}\n"
                 f"Órdenes realizadas: {stats['total_orders']}\n"
                 f"Pruebas realizadas: {stats['total_tests_conducted']}")
         self.stats_label.setText(text)
         # Llenar tabla de categorías
         self.stats_table.setRowCount(0)
         for (cat, count) in stats['by_category']:
             row = self.stats_table.rowCount()
             self.stats_table.insertRow(row)
             self.stats_table.setItem(row, 0, QTableWidgetItem(cat))
             self.stats_table.setItem(row, 1, QTableWidgetItem(str(count)))
         self.load_activity_summary()
 
     def _update_range_controls(self):
         if not hasattr(self, 'range_combo'):
             return
         is_custom = self.range_combo.currentIndex() == 4
         if hasattr(self, 'start_date_edit'):
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3349,145 +3668,201 @@ class MainWindow(QMainWindow):
             if start_date.month == 12:
                 next_month = datetime.date(start_date.year + 1, 1, 1)
             else:
                 next_month = datetime.date(start_date.year, start_date.month + 1, 1)
             end_date = next_month - datetime.timedelta(days=1)
             description = f"Mes del {start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')}"
         elif idx == 3:  # Últimos 30 días
             start_date = today - datetime.timedelta(days=29)
             end_date = today
             description = f"Últimos 30 días ({start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')})"
         else:  # Rango personalizado
             if hasattr(self, 'start_date_edit') and hasattr(self, 'end_date_edit'):
                 start_q = self.start_date_edit.date()
                 end_q = self.end_date_edit.date()
                 if start_q.isValid():
                     start_date = datetime.date(start_q.year(), start_q.month(), start_q.day())
                 if end_q.isValid():
                     end_date = datetime.date(end_q.year(), end_q.month(), end_q.day())
             if end_date < start_date:
                 start_date, end_date = end_date, start_date
             description = f"Del {start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')}"
         start_dt = datetime.datetime.combine(start_date, datetime.time.min)
         end_dt = datetime.datetime.combine(end_date, datetime.time.max)
         return start_dt, end_dt, description
 
-    def load_activity_summary(self):
+
+def load_activity_summary(self):
+    if not hasattr(self, 'activity_table'):
+        return
+    start_dt, end_dt, description = self._get_selected_range()
+    rows = self.labdb.get_results_in_range(
+        start_dt.strftime("%Y-%m-%d %H:%M:%S"),
+        end_dt.strftime("%Y-%m-%d %H:%M:%S")
+    )
+    activity_data = []
+    for (
+        test_entry_id,
+        order_id,
+        date_str,
+        sample_date_str,
+        first,
+        last,
+        doc_type,
+        doc_number,
+        sex,
+        birth_date,
+        hcl,
+        age_years,
+        order_obs,
+        test_name,
+        category,
+        result,
+        sample_status,
+        sample_issue,
+        observation
+    ) in rows:
+        display_date = "-"
+        if sample_date_str:
+            try:
+                sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
+                display_date = sample_dt.strftime("%d/%m/%Y")
+            except Exception:
+                display_date = sample_date_str
+        if display_date == "-":
+            try:
+                order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
+                display_date = order_dt.strftime("%d/%m/%Y %H:%M")
+            except Exception:
+                display_date = date_str or "-"
+        patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
+        doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
+        age_display = str(age_years) if age_years not in (None, "") else "-"
+        context = {
+            "patient": {"sex": sex, "birth_date": birth_date},
+            "order": {"age_years": age_years}
+        }
+        summary_items = self._build_registry_summary(test_name, result, context=context)
+        if not summary_items:
+            continue
+        result_text = "; ".join(summary_items)
+        activity_data.append({
+            "entry_id": test_entry_id,
+            "order_id": order_id,
+            "date": display_date,
+            "order_date_raw": date_str,
+            "sample_date_raw": sample_date_str,
+            "patient": patient_name,
+            "document": doc_text,
+            "doc_type": doc_type,
+            "doc_number": doc_number,
+            "birth_date": birth_date,
+            "hcl": hcl,
+            "age": age_display,
+            "test": test_name,
+            "result": result_text,
+            "summary_items": summary_items,
+            "category": category,
+            "order_observations": order_obs,
+            "emitted": None,
+            "emitted_at": None,
+            "first_name": first,
+            "last_name": last,
+            "sample_status": sample_status,
+            "sample_issue": sample_issue,
+            "observation": observation
+        })
+    self._activity_cache = {
+        "data": activity_data,
+        "description": description,
+        "start": start_dt,
+        "end": end_dt
+    }
+    self.activity_table.setRowCount(len(activity_data))
+    for row_idx, item in enumerate(activity_data):
+        self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
+        order_item = QTableWidgetItem(str(item["order_id"]))
+        order_item.setTextAlignment(Qt.AlignCenter)
+        self.activity_table.setItem(row_idx, 1, order_item)
+        self.activity_table.setItem(row_idx, 2, QTableWidgetItem(item["patient"]))
+        self.activity_table.setItem(row_idx, 3, QTableWidgetItem(item["document"]))
+        age_item = QTableWidgetItem(item["age"])
+        age_item.setTextAlignment(Qt.AlignCenter)
+        self.activity_table.setItem(row_idx, 4, age_item)
+        self.activity_table.setItem(row_idx, 5, QTableWidgetItem(item["test"]))
+        status_text = self._format_sample_status_text(item.get("sample_status"), item.get("sample_issue"))
+        self.activity_table.setItem(row_idx, 6, QTableWidgetItem(status_text or "-"))
+        self.activity_table.setItem(row_idx, 7, QTableWidgetItem(item["result"]))
+    if hasattr(self, 'activity_caption'):
+        self.activity_caption.setText(
+            f"Registro de pruebas: {description} - {len(activity_data)} resultado(s)"
+        )
+
+
+    def delete_selected_activity_entries(self):
         if not hasattr(self, 'activity_table'):
             return
-        start_dt, end_dt, description = self._get_selected_range()
-        rows = self.labdb.get_results_in_range(
-            start_dt.strftime("%Y-%m-%d %H:%M:%S"),
-            end_dt.strftime("%Y-%m-%d %H:%M:%S")
+        selected = self.activity_table.selectionModel().selectedRows() if self.activity_table.selectionModel() else []
+        if not selected:
+            QMessageBox.information(self, "Sin selección", "Seleccione al menos un resultado para eliminar.")
+            return
+        if not getattr(self, '_activity_cache', None):
+            self.load_activity_summary()
+        cache = getattr(self, '_activity_cache', {"data": []})
+        entries = cache.get("data", [])
+        selected_ids = []
+        for model_index in selected:
+            row = model_index.row()
+            if 0 <= row < len(entries):
+                entry = entries[row]
+                entry_id = entry.get("entry_id")
+                if entry_id:
+                    selected_ids.append(entry_id)
+        if not selected_ids:
+            QMessageBox.warning(self, "Sin datos", "No se pudo identificar los registros seleccionados.")
+            return
+        dialog = ReasonDialog(
+            "Eliminar resultados",
+            "Indique el motivo de eliminación de los resultados seleccionados.",
+            self,
+            placeholder="Motivo (ej. duplicidad, prueba, corrección)"
         )
-        activity_data = []
-        for (
-            order_id,
-            date_str,
-            sample_date_str,
-            first,
-            last,
-            doc_type,
-            doc_number,
-            sex,
-            birth_date,
-            hcl,
-            age_years,
-            order_obs,
-            test_name,
-            category,
-            result
-        ) in rows:
-            display_date = "-"
-            if sample_date_str:
-                try:
-                    sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
-                    display_date = sample_dt.strftime("%d/%m/%Y")
-                except Exception:
-                    display_date = sample_date_str
-            if display_date == "-":
-                try:
-                    order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
-                    display_date = order_dt.strftime("%d/%m/%Y %H:%M")
-                except Exception:
-                    display_date = date_str or "-"
-            patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
-            doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
-            age_display = str(age_years) if age_years not in (None, "") else "-"
-            context = {
-                "patient": {"sex": sex, "birth_date": birth_date},
-                "order": {"age_years": age_years}
-            }
-            summary_items = self._build_registry_summary(test_name, result, context=context)
-            if not summary_items:
-                continue
-            result_text = "; ".join(summary_items)
-            activity_data.append({
-                "order_id": order_id,
-                "date": display_date,
-                "order_date_raw": date_str,
-                "sample_date_raw": sample_date_str,
-                "patient": patient_name,
-                "document": doc_text,
-                "doc_type": doc_type,
-                "doc_number": doc_number,
-                "birth_date": birth_date,
-                "hcl": hcl,
-                "age": age_display,
-                "test": test_name,
-                "result": result_text,
-                "summary_items": summary_items,
-                "category": category,
-                "order_observations": order_obs,
-                "emitted": None,
-                "emitted_at": None,
-                "first_name": first,
-                "last_name": last
-            })
-        self._activity_cache = {
-            "data": activity_data,
-            "description": description,
-            "start": start_dt,
-            "end": end_dt
-        }
-        self.activity_table.setRowCount(len(activity_data))
-        for row_idx, item in enumerate(activity_data):
-            self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
-            order_item = QTableWidgetItem(str(item["order_id"]))
-            order_item.setTextAlignment(Qt.AlignCenter)
-            self.activity_table.setItem(row_idx, 1, order_item)
-            self.activity_table.setItem(row_idx, 2, QTableWidgetItem(item["patient"]))
-            self.activity_table.setItem(row_idx, 3, QTableWidgetItem(item["document"]))
-            age_item = QTableWidgetItem(item["age"])
-            age_item.setTextAlignment(Qt.AlignCenter)
-            self.activity_table.setItem(row_idx, 4, age_item)
-            self.activity_table.setItem(row_idx, 5, QTableWidgetItem(item["test"]))
-            self.activity_table.setItem(row_idx, 6, QTableWidgetItem(item["result"]))
-        if hasattr(self, 'activity_caption'):
-            self.activity_caption.setText(
-                f"Registro de pruebas: {description} - {len(activity_data)} resultado(s)"
-            )
+        dialog.text_edit.setPlainText("Duplicidad de registro")
+        if dialog.exec_() != QDialog.Accepted:
+            return
+        reason = dialog.get_reason() or "Sin motivo"
+        removed = 0
+        for entry_id in selected_ids:
+            if self.labdb.delete_order_test(entry_id, reason, self.user.get('id')):
+                removed += 1
+        if removed:
+            QMessageBox.information(self, "Resultados eliminados", f"Se eliminaron {removed} resultado(s) del registro.")
+            self.load_activity_summary()
+            self.populate_pending_orders()
+            self.populate_completed_orders()
+        else:
+            QMessageBox.warning(self, "Sin cambios", "No se eliminaron registros. Verifique el estado de las órdenes seleccionadas.")
 
     def export_activity_record(self, fmt):
         if fmt not in {"pdf", "csv"}:
             return
         if not getattr(self, '_activity_cache', None):
             self.load_activity_summary()
         cache = getattr(self, '_activity_cache', {"data": [], "description": ""})
         data = cache.get("data", [])
         if not data:
             QMessageBox.information(self, "Sin datos", "No hay registros para el período seleccionado.")
             return
         description = cache.get("description", "")
         if fmt == "csv":
             file_path, _ = QFileDialog.getSaveFileName(
                 self,
                 "Exportar registro",
                 "registro.csv",
                 "Archivo CSV (*.csv)"
             )
             if not file_path:
                 return
             if not file_path.lower().endswith(".csv"):
                 file_path += ".csv"
             try:
                 with open(file_path, 'w', encoding='utf-8') as f:
diff --git a/main_window.py b/main_window.py
index 66fb15088584ac2b3d622b4933225ba614147d82..35b8ebc06910d164f33888ec7504abd494b18b49 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3649,155 +4024,164 @@ class MainWindow(QMainWindow):
                 group_text(entry, "others")
             ]
             render_row(ordered_cells)
         try:
             pdf.output(file_path)
         except Exception as exc:
             QMessageBox.warning(self, "Error", f"No se pudo generar el PDF:\n{exc}")
             return
         QMessageBox.information(self, "Exportado", f"Registro guardado en:\n{file_path}")
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
 
     def _on_history_selection_changed(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         has_selection = bool(selection.selectedRows()) if selection else False
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(has_selection)
 
+
     def search_patient_history(self):
         if not hasattr(self, 'history_table'):
             return
         doc_number = self.history_doc_input.text().strip() if hasattr(self, 'history_doc_input') else ""
         if doc_number == "":
             QMessageBox.warning(self, "DNI requerido", "Ingrese un DNI para realizar la búsqueda.")
             return
         if not doc_number.isdigit():
             QMessageBox.warning(self, "Formato inválido", "El DNI debe contener solo números.")
             return
         self._clear_history_table()
         rows = self.labdb.get_patient_history_by_document(doc_number, "DNI")
         records = []
         for row in rows:
             (
                 order_id,
                 date_str,
                 sample_date_str,
                 test_name,
                 raw_result,
                 category,
                 first_name,
                 last_name,
                 doc_type,
                 doc_value,
                 sex,
                 birth_date,
                 hcl,
                 age_years,
                 order_obs,
                 emitted,
-                emitted_at
+                emitted_at,
+                sample_status,
+                sample_issue,
+                observation,
+                entry_id
             ) = row
             display_date = "-"
             if sample_date_str:
                 try:
                     sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
                     display_date = sample_dt.strftime("%d/%m/%Y")
                 except Exception:
                     display_date = sample_date_str
             if display_date == "-":
                 try:
                     order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
                     display_date = order_dt.strftime("%d/%m/%Y %H:%M")
                 except Exception:
                     display_date = date_str or "-"
             patient_name = " ".join(part for part in [(first_name or "").upper(), (last_name or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_value) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
             context = {
                 "patient": {"sex": sex, "birth_date": birth_date},
                 "order": {"age_years": age_years}
             }
             summary_items = self._build_registry_summary(test_name, raw_result, context=context)
             if not summary_items:
                 continue
             result_text = "; ".join(summary_items)
             records.append({
+                "entry_id": entry_id,
                 "order_id": order_id,
                 "date": display_date,
                 "order_date_raw": date_str,
                 "sample_date_raw": sample_date_str,
                 "patient": patient_name,
                 "document": doc_text,
                 "doc_type": doc_type,
                 "doc_number": doc_value,
                 "birth_date": birth_date,
                 "hcl": hcl,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "summary_items": summary_items,
                 "category": category,
                 "order_observations": order_obs,
                 "emitted": emitted,
                 "emitted_at": emitted_at,
                 "first_name": first_name,
-                "last_name": last_name
+                "last_name": last_name,
+                "sample_status": sample_status,
+                "sample_issue": sample_issue,
+                "observation": observation
             })
         aggregated = self._aggregate_results_by_order(records)
         self._history_results = aggregated
         self.history_table.setRowCount(len(aggregated))
         headers = [
             "date",
             "order_id",
             "patient",
             "document",
             "age",
             "hematology",
             "biochemistry",
             "micro_parasito",
             "others",
             "emitted"
         ]
         for row_idx, entry in enumerate(aggregated):
             values = [
                 self._format_date_for_registry(entry),
                 str(entry.get("order_id", "-")),
                 entry.get("patient", "-"),
                 entry.get("document", "-"),
                 entry.get("age", "-"),
-                "\n".join(entry.get("groups", {}).get("hematology", [])) or "-",
-                "\n".join(entry.get("groups", {}).get("biochemistry", [])) or "-",
-                "\n".join(entry.get("groups", {}).get("micro_parasito", [])) or "-",
-                "\n".join(entry.get("groups", {}).get("others", [])) or "-",
+                "\n  ".join(entry.get("groups", {}).get("hematology", [])) or "-",
+                "\n  ".join(entry.get("groups", {}).get("biochemistry", [])) or "-",
+                "\n  ".join(entry.get("groups", {}).get("micro_parasito", [])) or "-",
+                "\n  ".join(entry.get("groups", {}).get("others", [])) or "-",
                 self._format_emission_status(entry.get("emitted"), entry.get("emitted_at"))
             ]
             for col_idx, value in enumerate(values):
                 item = QTableWidgetItem(str(value))
                 if headers[col_idx] in {"order_id", "age"}:
                     item.setTextAlignment(Qt.AlignCenter)
                 self.history_table.setItem(row_idx, col_idx, item)
         if not aggregated:
             QMessageBox.information(self, "Sin resultados", "No se encontró historial con resultados registrados para este DNI.")
         self._on_history_selection_changed()
 
     def open_history_order_from_analysis(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         if not selection:
             return
         indexes = selection.selectedRows()
         if not indexes:
             QMessageBox.information(self, "Sin selección", "Seleccione una orden para abrirla en la emisión.")
             return
         row = indexes[0].row()
         history_items = getattr(self, '_history_results', [])
         if row >= len(history_items):
             return
