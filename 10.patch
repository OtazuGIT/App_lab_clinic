diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1,30 +1,32 @@
 # main_window.py
 import copy
 import datetime
 import json
 import os
+import re
+import unicodedata
 from collections import OrderedDict
 from PyQt5.QtWidgets import (QMainWindow, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
                              QStackedWidget, QFormLayout, QScrollArea, QGroupBox, QComboBox,
                              QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, QCheckBox,
                              QDateEdit, QRadioButton, QButtonGroup, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem)
 from PyQt5.QtCore import QDate, QDateTime, Qt, QTimer
 from fpdf import FPDF  # Asegúrese de tener fpdf instalado (pip install fpdf)
 
 LAB_TITLE = "Laboratorio P.S. Iñapari - 002789"
 
 # Definiciones de plantillas de resultados estructurados por examen
 HEMOGRAM_BASE_FIELDS = [
     {
         "key": "hematocrito",
         "label": "Hematocrito (Hto)",
         "unit": "%",
         "reference": (
             "RN: 44-65 %\n"
             "Niños 1-10 a: 35-45 %\n"
             "Hombres adultos: 40-54 %\n"
             "Mujeres adultas: 36-47 %\n"
             "Gestantes (2°-3° trim): 33-43 %"
         ),
         "placeholder": "Ej. 42.5"
     },
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -955,50 +957,51 @@ class AddTestsDialog(QDialog):
         return [item.data(Qt.UserRole) for item in self.list_widget.selectedItems() if item.flags() & Qt.ItemIsEnabled]
 
 
 class MainWindow(QMainWindow):
     def __init__(self, labdb, user):
         super().__init__()
         self.labdb = labdb
         self.user = user
         self.setWindowTitle(LAB_TITLE)
         # Configuración de ventana principal y menú lateral
         central_widget = QWidget()
         main_layout = QHBoxLayout(central_widget)
         side_menu_layout = QVBoxLayout()
         side_menu_widget = QWidget()
         side_menu_widget.setLayout(side_menu_layout)
         side_menu_widget.setFixedWidth(200)
         side_menu_widget.setStyleSheet("background-color: #2c3e50;")
         title_label = QLabel(LAB_TITLE)
         title_label.setStyleSheet("color: white; font-size: 16px; font-weight: bold;")
         title_label.setAlignment(Qt.AlignCenter)
         title_label.setWordWrap(True)
         side_menu_layout.addWidget(title_label)
         side_menu_layout.addSpacing(10)
         # Secciones/Páginas
         self.stack = QStackedWidget()
+        self.current_order_context = None
         # Contenedor principal con cabecera y reloj
         content_widget = QWidget()
         content_layout = QVBoxLayout(content_widget)
         header_layout = QHBoxLayout()
         header_title = QLabel(LAB_TITLE)
         header_title.setStyleSheet("font-size: 18px; font-weight: bold; color: #2c3e50;")
         header_title.setWordWrap(True)
         self.clock_label = QLabel()
         self.clock_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
         self.clock_label.setStyleSheet("font-size: 16px; color: #0a84ff;")
         header_layout.addWidget(header_title)
         header_layout.addStretch()
         header_layout.addWidget(self.clock_label)
         content_layout.addLayout(header_layout)
         content_layout.addWidget(self.stack)
         # 1. Página de Registro de Pacientes
         self.page_registro = QWidget(); self.init_registro_page()
         self.stack.addWidget(self.page_registro)
         btn_reg = QPushButton("Registro"); btn_reg.setStyleSheet("background-color: #4CAF50; color: white; font-size: 14px;")
         btn_reg.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_registro))
         side_menu_layout.addWidget(btn_reg)
         # 2. Página de Ingreso de Resultados
         self.page_resultados = QWidget(); self.init_resultados_page()
         self.stack.addWidget(self.page_resultados)
         btn_res = QPushButton("Anotar Resultados"); btn_res.setStyleSheet("background-color: #4CAF50; color: white; font-size: 14px;")
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1540,136 +1543,170 @@ class MainWindow(QMainWindow):
         selected = None
         for candidate in target_candidates:
             if candidate is not None and candidate in available_ids:
                 selected = candidate
                 break
         if selected is not None:
             self._select_order_in_combo(self.combo_completed, selected)
         else:
             self.combo_completed.setCurrentIndex(0)
         self.combo_completed.blockSignals(False)
     def load_order_fields(self):
         # Cargar campos de resultado para la orden seleccionada
         self._clear_results_layout()
         self.order_fields.clear()
         data = self.combo_orders.currentData() if hasattr(self, 'combo_orders') else None
         if data is None:
             self.selected_order_id = None
             placeholder = QLabel("Seleccione una orden pendiente para registrar resultados.")
             placeholder.setStyleSheet("color: #555; font-style: italic;")
             placeholder.setWordWrap(True)
             self.results_layout.addWidget(placeholder)
             self.results_layout.addStretch()
             return
         order_id = int(data)
         self.selected_order_id = order_id
-        # Consultar pruebas de esa orden
-        self.labdb.cur.execute("""
-            SELECT t.name, ot.result, t.category
-            FROM order_tests ot
-            JOIN tests t ON ot.test_id = t.id
-            WHERE ot.order_id=?
-        """, (order_id,))
-        rows = self.labdb.cur.fetchall()
+        info = self.labdb.get_order_details(order_id)
+        if not info:
+            empty_label = QLabel("La orden seleccionada no tiene pruebas registradas.")
+            empty_label.setStyleSheet("color: #555; font-style: italic;")
+            empty_label.setWordWrap(True)
+            self.results_layout.addWidget(empty_label)
+            self.results_layout.addStretch()
+            self.populate_pending_orders()
+            return
+        patient_info = info.get("patient", {})
+        order_info = info.get("order", {})
+        rows = info.get("results", [])
+        self.current_order_context = {"patient": patient_info, "order": order_info}
         if not rows:
             empty_label = QLabel("La orden seleccionada no tiene pruebas asociadas.")
             empty_label.setStyleSheet("color: #555; font-style: italic;")
             empty_label.setWordWrap(True)
             self.results_layout.addWidget(empty_label)
             self.results_layout.addStretch()
             return
         order_test_names = [name for name, _, _ in rows]
         for test_name, raw_result, category in rows:
             template = None
             template_name = test_name
             if test_name == "Hematocrito":
                 auto_mode = self._should_auto_calculate_hb(order_test_names)
                 template = build_hematocrit_template(auto_mode)
                 if auto_mode:
                     template_name = "Hematocrito (automático)"
                     TEST_TEMPLATES[template_name] = copy.deepcopy(template)
             else:
                 base_template = TEST_TEMPLATES.get(test_name)
                 if base_template is not None:
                     template = copy.deepcopy(base_template)
                 elif category == "PRUEBAS RÁPIDAS":
                     template = build_bool_observation_template()
                     TEST_TEMPLATES[test_name] = copy.deepcopy(template)
             group_box = QGroupBox(test_name)
             group_box.setStyleSheet("QGroupBox { font-weight: bold; }")
+            container_layout = QVBoxLayout()
+            header_layout = QHBoxLayout()
+            header_layout.addStretch()
+            remove_button = QPushButton("Quitar examen")
+            remove_button.setStyleSheet("QPushButton { font-size: 10px; color: #c0392b; }")
+            remove_button.clicked.connect(lambda _=False, name=test_name: self._prompt_remove_test(name))
+            header_layout.addWidget(remove_button)
+            container_layout.addLayout(header_layout)
             group_layout = QFormLayout()
             group_layout.setLabelAlignment(Qt.AlignLeft)
-            group_box.setLayout(group_layout)
+            container_layout.addLayout(group_layout)
+            group_box.setLayout(container_layout)
             parsed = self._parse_stored_result(raw_result)
             existing_values = {}
             if parsed.get("type") == "structured":
                 existing_values = parsed.get("values", {})
             field_entries = {}
             if template:
                 for field_def in template.get("fields", []):
                     if field_def.get("type") == "section":
                         section_label = QLabel(field_def.get("label", ""))
                         section_label.setStyleSheet("font-weight: bold; color: #2c3e50; padding-top:4px;")
                         group_layout.addRow(section_label)
                         continue
-                    label_text, field_widget, widget_info = self._create_structured_field(field_def, existing_values)
+                    label_text, field_widget, widget_info = self._create_structured_field(field_def, existing_values, self.current_order_context)
                     widget_info["definition"] = field_def
                     key = field_def.get("key")
                     if key:
                         field_entries[key] = widget_info
                     group_layout.addRow(f"{label_text}:", field_widget)
                 self._apply_auto_calculations(field_entries, template)
                 self.order_fields[test_name] = {
                     "template": template,
                     "template_name": template_name,
                     "fields": field_entries
                 }
             else:
                 default_value = ""
                 if parsed.get("type") == "text":
                     default_value = parsed.get("value", "")
                 elif parsed.get("type") == "structured":
                     default_value = self._structured_dict_to_text(parsed.get("values", {}))
                 edit = QLineEdit()
                 edit.setText(default_value)
                 group_layout.addRow("Resultado:", edit)
                 self.order_fields[test_name] = {
                     "template": None,
                     "fields": {
                         "__value__": {
                             "type": "line",
                             "widget": edit,
                             "definition": {"key": "__value__", "label": "Resultado"}
                         }
                     }
                 }
             self.results_layout.addWidget(group_box)
         self.results_layout.addStretch()
 
     def _should_auto_calculate_hb(self, order_test_names):
         valid_names = [name for name in order_test_names if name]
         return valid_names.count("Hematocrito") == 1 and len(valid_names) == 1
+
+    def _prompt_remove_test(self, test_name):
+        if not self.selected_order_id:
+            return
+        reply = QMessageBox.question(
+            self,
+            "Quitar examen",
+            f"¿Desea quitar la prueba '{test_name}' de la orden seleccionada?",
+            QMessageBox.Yes | QMessageBox.No
+        )
+        if reply == QMessageBox.No:
+            return
+        removed = self.labdb.remove_test_from_order(self.selected_order_id, test_name)
+        if removed:
+            QMessageBox.information(self, "Prueba eliminada", f"Se quitó '{test_name}' de la orden.")
+            self.populate_pending_orders()
+            self.populate_completed_orders()
+            self.load_order_fields()
+        else:
+            QMessageBox.warning(self, "Acción no realizada", "No se pudo quitar la prueba seleccionada.")
     def save_results(self):
         # Guardar los resultados ingresados para la orden seleccionada
         if not self.selected_order_id:
             return
         results_dict = {}
         has_empty = False
         for test_name, info in self.order_fields.items():
             template = info.get("template")
             if template:
                 values = {}
                 for key, field_info in info["fields"].items():
                     value = self._get_widget_value(field_info)
                     values[key] = value
                     if value == "" and not field_info["definition"].get("optional", False):
                         has_empty = True
                 results_dict[test_name] = {
                     "type": "structured",
                     "template": info.get("template_name", test_name),
                     "values": values
                 }
             else:
                 field_info = info["fields"].get("__value__")
                 value = self._get_widget_value(field_info)
                 results_dict[test_name] = value
                 if value == "":
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1678,56 +1715,57 @@ class MainWindow(QMainWindow):
             reply = QMessageBox.question(
                 self,
                 "Confirmar",
                 "Hay pruebas o campos sin resultado. ¿Guardar de todos modos?",
                 QMessageBox.Yes | QMessageBox.No
             )
             if reply == QMessageBox.No:
                 return
         completed = self.labdb.save_results(self.selected_order_id, results_dict)
         if completed:
             QMessageBox.information(self, "Completado", "Resultados guardados. Orden marcada como completada.")
             self.selected_order_id = None
             self.populate_pending_orders()
             self._clear_results_layout()
             msg = QLabel("Seleccione otra orden pendiente para continuar con la digitación de resultados.")
             msg.setStyleSheet("color: #555; font-style: italic;")
             msg.setWordWrap(True)
             self.results_layout.addWidget(msg)
             self.results_layout.addStretch()
         else:
             QMessageBox.information(self, "Guardado", "Resultados guardados (orden aún incompleta).")
             self.load_order_fields()
     def _clear_results_layout(self):
         if not hasattr(self, 'results_layout'):
             return
+        self.current_order_context = None
         while self.results_layout.count():
             item = self.results_layout.takeAt(0)
             widget = item.widget()
             if widget:
                 widget.deleteLater()
-    def _create_structured_field(self, field_def, existing_values):
+    def _create_structured_field(self, field_def, existing_values, context=None):
         key = field_def.get("key")
         value = ""
         if key:
             value = existing_values.get(key, "")
         container = QWidget()
         layout = QHBoxLayout(container)
         layout.setContentsMargins(0, 0, 0, 0)
         layout.setSpacing(6)
         widget_info = {"key": key, "container": container}
         field_type = field_def.get("type", "text")
         if field_type == "choice":
             combo = QComboBox()
             combo.addItems(field_def.get("choices", []))
             if value:
                 idx = combo.findText(value)
                 if idx >= 0:
                     combo.setCurrentIndex(idx)
                 else:
                     combo.addItem(value)
                     combo.setCurrentIndex(combo.count() - 1)
             else:
                 if combo.count():
                     combo.setCurrentIndex(-1)
             layout.addWidget(combo)
             widget_info.update({"type": "combo", "widget": combo})
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1756,51 +1794,51 @@ class MainWindow(QMainWindow):
                     neg_radio.setChecked(True)
         elif field_type == "text_area":
             text_edit = QTextEdit()
             text_edit.setFixedHeight(field_def.get("height", 70))
             placeholder = field_def.get("placeholder")
             if placeholder:
                 text_edit.setPlaceholderText(placeholder)
             if value:
                 text_edit.setPlainText(value)
             layout.addWidget(text_edit)
             widget_info.update({"type": "text_area", "widget": text_edit})
         else:
             edit = QLineEdit()
             placeholder = field_def.get("placeholder")
             if placeholder:
                 edit.setPlaceholderText(placeholder)
             if value:
                 edit.setText(value)
             layout.addWidget(edit)
             widget_info.update({"type": "line", "widget": edit})
         unit = field_def.get("unit")
         if unit and field_type not in ("bool",):
             unit_label = QLabel(unit)
             unit_label.setStyleSheet("color: #555; font-size: 11px;")
             layout.addWidget(unit_label)
-        reference = field_def.get("reference")
+        reference = self._get_field_reference(field_def, context)
         if reference:
             ref_label = QLabel(f"Ref: {reference}")
             ref_label.setWordWrap(True)
             ref_label.setStyleSheet("color: #777; font-size: 11px;")
             layout.addWidget(ref_label)
         helper = field_def.get("helper")
         if helper:
             helper_label = QLabel(helper)
             helper_label.setWordWrap(True)
             helper_label.setStyleSheet("color: #0a84ff; font-size: 10px;")
             layout.addWidget(helper_label)
         layout.addStretch()
         widget_info["unit"] = unit
         widget_info["reference"] = reference
         return field_def.get("label", key or ""), container, widget_info
     def _apply_auto_calculations(self, field_entries, template):
         for calc in template.get("auto_calculations", []):
             self._setup_auto_calculation(field_entries, calc)
     def _setup_auto_calculation(self, field_entries, calc):
         source_key = calc.get("source")
         target_key = calc.get("target")
         if not source_key or not target_key:
             return
         source_info = field_entries.get(source_key)
         target_info = field_entries.get(target_key)
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1916,103 +1954,104 @@ class MainWindow(QMainWindow):
             return ""
         if not isinstance(text, str):
             text = str(text)
         replacements = {
             '\u2013': '-',
             '\u2014': '-',
             '\u2018': "'",
             '\u2019': "'",
             '\u201c': '"',
             '\u201d': '"'
         }
         for bad, good in replacements.items():
             text = text.replace(bad, good)
         try:
             text.encode('latin-1')
             return text
         except UnicodeEncodeError:
             return text.encode('latin-1', 'replace').decode('latin-1')
 
     def _is_blank_result(self, value):
         if value is None:
             return True
         if isinstance(value, str):
             return value.strip() == ""
         return False
-    def _format_result_lines(self, test_name, raw_result):
+    def _format_result_lines(self, test_name, raw_result, context=None):
         parsed = self._parse_stored_result(raw_result)
         template = TEST_TEMPLATES.get(test_name)
+        effective_context = context or self.current_order_context
         if parsed.get("type") == "structured" and template:
             values = parsed.get("values", {})
             value_lines = []
             pending_section = None
             for field_def in template.get("fields", []):
                 if field_def.get("type") == "section":
                     section_label = field_def.get("label", "")
                     pending_section = f"  {section_label}:" if section_label else None
                     continue
                 key = field_def.get("key")
                 if not key:
                     continue
                 value = values.get(key, "")
                 if isinstance(value, str):
                     stripped = value.strip()
                     if stripped == "":
                         continue
                     display_value = " ".join(value.splitlines()).strip()
                 else:
                     if self._is_blank_result(value):
                         continue
                     display_value = value
                 unit = field_def.get("unit")
                 field_type = field_def.get("type")
                 if unit and field_type not in ("bool", "text_area", "choice"):
                     display_text = str(display_value)
                     if not display_text.endswith(unit):
                         display_value = f"{display_text} {unit}"
-                reference = field_def.get("reference")
+                reference = self._get_field_reference(field_def, effective_context)
                 label = field_def.get("label", key)
                 if pending_section:
                     value_lines.append(pending_section)
                     pending_section = None
                 bullet = f"  • {label}: {display_value}"
                 if reference:
                     bullet += f" (Ref: {reference})"
                 value_lines.append(bullet)
             if not value_lines:
                 return []
             return [f"{test_name}:"] + value_lines
         text_value = parsed.get("value", raw_result or "")
         if isinstance(text_value, str):
             text_value = text_value.strip()
             if text_value == "":
                 return []
         elif self._is_blank_result(text_value):
             return []
         return [f"{test_name}: {text_value}"]
-    def _format_result_for_export(self, test_name, raw_result):
-        lines = self._format_result_lines(test_name, raw_result)
+    def _format_result_for_export(self, test_name, raw_result, context=None):
+        lines = self._format_result_lines(test_name, raw_result, context=context)
         if not lines:
             return ""
         if len(lines) <= 1:
             line = lines[0]
             parts = line.split(": ", 1)
             return parts[1] if len(parts) > 1 else line
         cleaned = []
         for line in lines[1:]:
             stripped = line.strip()
             if stripped.endswith(":") and "•" not in stripped:
                 continue
             cleaned.append(stripped.replace("• ", ""))
         return " | ".join(cleaned)
 
     def _map_category_group(self, category):
         normalized = (category or "").strip().upper()
         if normalized == "HEMATOLOGÍA":
             return "hematology"
         if normalized == "BIOQUÍMICA":
             return "biochemistry"
         if normalized in {"MICROBIOLOGÍA", "PARASITOLOGÍA", "MICROSCOPÍA"}:
             return "micro_parasito"
         return "others"
 
     def _aggregate_results_by_order(self, records):
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2063,87 +2102,210 @@ class MainWindow(QMainWindow):
                     parsed = datetime.datetime.strptime(emitted_at, "%Y-%m-%d %H:%M:%S")
                     return f"Sí ({parsed.strftime('%d/%m/%Y')})"
                 except Exception:
                     return "Sí"
             return "Sí"
         if emitted_flag == 0:
             return "No"
         return "-"
     def _calculate_age_years(self, patient_info, order_info):
         age_value = order_info.get('age_years') if isinstance(order_info, dict) else None
         if age_value is not None:
             try:
                 return int(age_value)
             except (TypeError, ValueError):
                 age_value = None
         if age_value is None:
             birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     age_value = bd.daysTo(QDate.currentDate()) // 365
         return age_value
     def _format_age_text(self, patient_info, order_info):
         age_value = self._calculate_age_years(patient_info, order_info)
         return f"{age_value} años" if age_value is not None else "-"
-    def _extract_result_structure(self, test_name, raw_result):
+
+    def _get_field_reference(self, field_def, context=None):
+        if not field_def:
+            return None
+        reference = field_def.get("reference")
+        if not reference:
+            return reference
+        effective_context = context or self.current_order_context
+        return self._filter_reference_for_context(reference, effective_context)
+
+    def _filter_reference_for_context(self, reference, context):
+        if not reference or not isinstance(reference, str):
+            return reference
+        if not context:
+            return reference
+        patient_info = context.get("patient", {}) if isinstance(context, dict) else {}
+        order_info = context.get("order", {}) if isinstance(context, dict) else {}
+        age_value = self._calculate_age_years(patient_info, order_info)
+        sex_text = self._normalize_text(patient_info.get("sex", ""))
+        segments = self._split_reference_segments(reference)
+        applicable = []
+        general_segments = []
+        for segment in segments:
+            classification = self._classify_reference_segment(segment)
+            if self._segment_matches_context(classification, age_value, sex_text):
+                applicable.append(segment.strip())
+            elif not classification['groups'] and not classification['sexes']:
+                general_segments.append(segment.strip())
+        if applicable:
+            return "\n".join(applicable)
+        if general_segments:
+            return "\n".join(general_segments)
+        return reference
+
+    def _split_reference_segments(self, reference_text):
+        segments = []
+        for raw_line in str(reference_text).split('\n'):
+            for part in raw_line.split('|'):
+                cleaned = part.strip()
+                if cleaned:
+                    segments.append(cleaned)
+        return segments or [str(reference_text).strip()]
+
+    def _normalize_text(self, text):
+        if not isinstance(text, str):
+            text = str(text or "")
+        normalized = unicodedata.normalize("NFD", text.lower())
+        return "".join(ch for ch in normalized if unicodedata.category(ch) != 'Mn')
+
+    def _classify_reference_segment(self, segment):
+        normalized = self._normalize_text(segment)
+        groups = set()
+        sexes = set()
+        if any(keyword in normalized for keyword in ["rn", "recien nacido", "neon", "lactant"]):
+            groups.add('newborn')
+        if any(keyword in normalized for keyword in ["nino", "ninos", "infantil", "pediatr", "menor", "adolesc"]):
+            groups.add('child')
+        if "mes" in normalized:
+            groups.add('child')
+        if any(keyword in normalized for keyword in ["adulto", "adultos", "mayor", "ancian", "geriatr"]):
+            groups.add('adult')
+        if any(keyword in normalized for keyword in ["mujer", "mujeres", "femen"]):
+            sexes.add('female')
+            groups.add('adult')
+        if any(keyword in normalized for keyword in ["hombre", "hombres", "varon", "varones", "mascul"]):
+            sexes.add('male')
+            groups.add('adult')
+        if "gestant" in normalized or "embaraz" in normalized:
+            sexes.add('female')
+            groups.add('adult')
+        for match in re.finditer(r'(\d+)\s*[-–]\s*(\d+)\s*(?:anos|ano|a)', normalized):
+            start = int(match.group(1))
+            end = int(match.group(2))
+            self._assign_age_range_groups(groups, start, end)
+        for match in re.finditer(r'(?:>=|<=|>|<)?\s*(\d+)\s*(?:anos|ano|a)', normalized):
+            age = int(match.group(1))
+            self._assign_age_range_groups(groups, age, age)
+        for match in re.finditer(r'(\d+)\s*(?:mes|meses)', normalized):
+            months = int(match.group(1))
+            groups.add('child')
+            if months <= 1:
+                groups.add('newborn')
+        return {"groups": groups, "sexes": sexes}
+
+    def _assign_age_range_groups(self, groups, start_age, end_age):
+        if end_age < 0 or start_age < 0:
+            return
+        if end_age >= 18 and start_age >= 18:
+            groups.add('adult')
+        elif end_age < 18:
+            if end_age <= 1:
+                groups.add('newborn')
+            groups.add('child')
+        else:
+            groups.update({'child', 'adult'})
+
+    def _segment_matches_context(self, classification, age_value, normalized_sex):
+        groups = classification.get('groups', set())
+        sexes = classification.get('sexes', set())
+        if age_value is None:
+            return self._segment_matches_sex(sexes, normalized_sex)
+        target_groups = set()
+        if age_value <= 0:
+            target_groups.add('newborn')
+        if age_value < 18:
+            target_groups.add('child')
+        if age_value >= 18:
+            target_groups.add('adult')
+        if groups and not groups.intersection(target_groups):
+            return False
+        return self._segment_matches_sex(sexes, normalized_sex)
+
+    def _segment_matches_sex(self, sexes, normalized_sex):
+        if not sexes:
+            return True
+        if not normalized_sex:
+            return True
+        if any(keyword in normalized_sex for keyword in ["femen", "mujer"]):
+            return 'female' in sexes
+        if any(keyword in normalized_sex for keyword in ["mascul", "hombre", "varon"]):
+            return 'male' in sexes
+        return True
+    def _extract_result_structure(self, test_name, raw_result, context=None):
         parsed = self._parse_stored_result(raw_result)
         template_key = parsed.get("template") if isinstance(parsed, dict) else None
         template = TEST_TEMPLATES.get(template_key) if template_key in TEST_TEMPLATES else TEST_TEMPLATES.get(test_name)
+        effective_context = context or self.current_order_context
         if parsed.get("type") == "structured" and template:
             values = parsed.get("values", {})
             items = []
             pending_section = None
             for field_def in template.get("fields", []):
                 if field_def.get("type") == "section":
                     pending_section = field_def.get("label", "") or None
                     continue
                 key = field_def.get("key")
                 if not key:
                     continue
                 value = values.get(key, "")
                 if isinstance(value, str):
                     stripped = value.strip()
                     if stripped == "":
                         continue
                     display_value = " ".join(value.split())
                 else:
                     if self._is_blank_result(value):
                         continue
                     display_value = value
                 unit = field_def.get("unit")
                 field_type = field_def.get("type")
                 if unit and field_type not in ("bool", "text_area", "choice"):
                     display_value = f"{display_value} {unit}" if not str(display_value).endswith(unit) else display_value
                 if pending_section:
                     items.append({"type": "section", "label": pending_section})
                     pending_section = None
                 items.append({
                     "type": "value",
                     "label": field_def.get("label", key),
                     "value": display_value,
-                    "reference": field_def.get("reference")
+                    "reference": self._get_field_reference(field_def, effective_context)
                 })
             return {"type": "structured", "items": items}
         text_value = parsed.get("value", raw_result or "")
         if isinstance(text_value, str):
             text_value = text_value.strip()
             if text_value == "":
                 return {"type": "text", "value": ""}
         elif self._is_blank_result(text_value):
             return {"type": "text", "value": ""}
         return {"type": "text", "value": text_value}
     def _find_logo_path(self, position):
         if position not in {"left", "center", "right"}:
             return None
         search_dirs = ["", "assets", "resources", "images", "img", "static"]
         base_names = [
             f"logo_{position}.png",
             f"logo_{position}.jpg",
             f"logo_{position}.jpeg",
             f"{position}_logo.png",
             f"{position}_logo.jpg",
         ]
         if position == "center":
             base_names.extend([
                 "logo.png",
                 "logo_central.png",
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2244,73 +2406,74 @@ class MainWindow(QMainWindow):
         )
         self.selected_order_id = order_id
         self.populate_pending_orders()
         self.populate_completed_orders()
         reply = QMessageBox.question(
             self,
             "Registrar resultados",
             "¿Desea ir a la pantalla de resultados para completar las nuevas pruebas?",
             QMessageBox.Yes | QMessageBox.No
         )
         if reply == QMessageBox.Yes:
             self.stack.setCurrentWidget(self.page_resultados)
             if hasattr(self, 'combo_orders'):
                 self._select_order_in_combo(self.combo_orders, order_id)
             self.load_order_fields()
     def display_selected_result(self):
         # Mostrar los resultados de la orden seleccionada en el cuadro de texto
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
             return
         pat = info["patient"]; ord_inf = info["order"]; results = info["results"]
+        context = {"patient": pat, "order": ord_inf}
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
         lines = [f"PACIENTE: {pat.get('name') or '-'}", f"DOCUMENTO: {doc_text}"]
         age_value = self._calculate_age_years(pat, ord_inf)
         lines.append(f"EDAD: {age_value} AÑOS" if age_value is not None else "EDAD: -")
         lines.append(f"SEXO: {pat.get('sex') or '-'}")
         lines.append(f"HISTORIA CLÍNICA: {pat.get('hcl') or '-'}")
         lines.append(f"PROCEDENCIA: {pat.get('origin') or '-'}")
         lines.append(f"FECHA DE MUESTRA: {ord_inf.get('date') or '-'}")
         lines.append(f"SOLICITANTE: {ord_inf.get('requested_by') or '-'}")
         lines.append(f"DIAGNÓSTICO PRESUNTIVO: {ord_inf.get('diagnosis') or '-'}")
         emission_raw = ord_inf.get('emitted_at')
         if emission_raw:
             try:
                 emission_dt = datetime.datetime.strptime(emission_raw, "%Y-%m-%d %H:%M:%S")
                 emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 emission_display = emission_raw
         else:
             emission_display = "Pendiente de emisión"
         lines.append(f"FECHA DE EMISIÓN: {emission_display}")
         lines.append("RESULTADOS:")
         for test_name, result, _ in results:
-            formatted_lines = self._format_result_lines(test_name, result)
+            formatted_lines = self._format_result_lines(test_name, result, context=context)
             if formatted_lines:
                 lines.extend(formatted_lines)
         if ord_inf["observations"]:
             lines.append(f"Observaciones: {ord_inf['observations']}")
         self.output_text.setPlainText("\n".join(lines))
 
     def export_pdf(self):
         # Exportar el resultado seleccionado a un archivo PDF
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
             return
         pat = info["patient"]; ord_inf = info["order"]; results = info["results"]
         suggested_name = f"Orden_{order_id}.pdf"
         options = QFileDialog.Options()
         file_path, _ = QFileDialog.getSaveFileName(self, "Guardar PDF", suggested_name, "Archivos PDF (*.pdf)", options=options)
         if not file_path:
             return
         if not file_path.lower().endswith(".pdf"):
             file_path += ".pdf"
         existing_emission = ord_inf.get('emitted_at')
         mark_as_emitted = not (ord_inf.get('emitted') and existing_emission)
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2328,59 +2491,90 @@ class MainWindow(QMainWindow):
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
         patient_name = (pat.get('name') or '-').upper()
         age_text = self._format_age_text(pat, ord_inf)
         order_date_text = ord_inf.get('date') or "-"
         sex_text = (pat.get('sex') or '-').upper()
         hcl_text = (pat.get('hcl') or '-').upper()
         origin_text = (pat.get('origin') or '-').upper()
         requester_text = (ord_inf.get('requested_by') or '-').upper()
         diagnosis_text = (ord_inf.get('diagnosis') or '-').upper()
         pdf = FPDF('P', 'mm', 'A4')
         pdf.set_margins(12, 12, 12)
         pdf.set_auto_page_break(True, margin=14)
         pdf.add_page()
         header_image_path = os.path.join("img", "img.png")
         info_pairs = [
             (("Paciente", patient_name), ("Edad", age_text)),
             (("Documento", doc_text.upper() if doc_text else "-"), ("Sexo", sex_text)),
             (("Historia clínica", hcl_text), ("Fecha emisión", emission_display)),
             (("Procedencia", origin_text), ("Fecha muestra", order_date_text)),
             (("Solicitante", requester_text), ("Diagnóstico presuntivo", diagnosis_text)),
         ]
 
         def draw_patient_info():
             col_width = (pdf.w - pdf.l_margin - pdf.r_margin) / 2
 
+            def wrap_value_lines(text, width):
+                safe_value = str(text) if text not in (None, "") else "-"
+                safe_value = self._ensure_latin1(safe_value)
+                segments = []
+                for part in safe_value.split('\n'):
+                    part = part.strip()
+                    if part:
+                        segments.append(part)
+                if not segments:
+                    segments = [safe_value.strip() or "-"]
+                lines = []
+                for segment in segments:
+                    words = segment.split()
+                    if not words:
+                        lines.append("-")
+                        continue
+                    current = words[0]
+                    for word in words[1:]:
+                        candidate = f"{current} {word}"
+                        if pdf.get_string_width(candidate) <= max(width, 1):
+                            current = candidate
+                        else:
+                            lines.append(current)
+                            current = word
+                    lines.append(current)
+                return lines or ["-"]
+
             def render_pair(label, value, x_start, width, start_y):
                 pdf.set_xy(x_start, start_y)
                 pdf.set_font("Arial", 'B', 7.2)
-                pdf.cell(width, 3.4, self._ensure_latin1(f"{label.upper()}:"), border=0)
+                pdf.cell(width, 3.2, self._ensure_latin1(f"{label.upper()}:"), border=0)
                 pdf.set_font("Arial", '', 7.2)
-                pdf.set_xy(x_start, pdf.get_y())
-                safe_value = str(value) if value not in (None, "") else "-"
-                pdf.multi_cell(width, 3.6, self._ensure_latin1(safe_value), border=0)
-                return pdf.get_y()
+                current_y = start_y + 3.2
+                value_lines = wrap_value_lines(value, width - 1.2)
+                line_height = 3.0
+                for line in value_lines:
+                    pdf.set_xy(x_start, current_y)
+                    pdf.cell(width, line_height, line, border=0)
+                    current_y += line_height
+                return current_y
 
             pdf.set_font("Arial", 'B', 8.8)
             pdf.set_text_color(30, 30, 30)
             pdf.cell(0, 5, self._ensure_latin1("Datos del paciente"), ln=1)
             pdf.set_text_color(0, 0, 0)
             pdf.ln(1)
             for left, right in info_pairs:
                 start_y = pdf.get_y()
                 left_end = render_pair(left[0], left[1], pdf.l_margin, col_width, start_y)
                 right_end = render_pair(right[0], right[1], pdf.l_margin + col_width, col_width, start_y)
                 pdf.set_y(max(left_end, right_end) + 1.2)
 
         def draw_page_header():
             top_y = max(5, pdf.t_margin - 6)
             header_drawn = False
             if os.path.exists(header_image_path):
                 try:
                     header_width = pdf.w - pdf.l_margin - pdf.r_margin
                     header_height = 27
                     pdf.image(header_image_path, x=pdf.l_margin, y=top_y, w=header_width, h=header_height)
                     pdf.set_y(top_y + header_height + 2)
                     header_drawn = True
                 except Exception:
                     header_drawn = False
             if not header_drawn:
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2491,51 +2685,51 @@ class MainWindow(QMainWindow):
             section_height = 4.2
             if ensure_space(section_height + 1):
                 on_new_page()
                 render_table_header(widths)
             pdf.set_font("Arial", 'B', 6.8)
             pdf.set_fill_color(242, 246, 253)
             pdf.set_text_color(47, 84, 150)
             pdf.cell(total_width, section_height, self._ensure_latin1(label), border=1, ln=1, align='L', fill=True)
             pdf.set_text_color(0, 0, 0)
 
         draw_page_header()
 
         table_total_width = pdf.w - pdf.l_margin - pdf.r_margin
         column_widths = [table_total_width * 0.38, table_total_width * 0.27, table_total_width * 0.35]
 
         def draw_test_header(title):
             ensure_space(9)
             pdf.set_font("Arial", 'B', 8.6)
             pdf.set_text_color(255, 255, 255)
             pdf.set_fill_color(46, 117, 182)
             pdf.cell(0, 6, self._ensure_latin1(title.upper()), ln=1, fill=True)
             pdf.set_text_color(0, 0, 0)
             pdf.ln(1.2)
 
         for test_name, raw_result, _ in results:
-            structure = self._extract_result_structure(test_name, raw_result)
+            structure = self._extract_result_structure(test_name, raw_result, context=context)
             if structure.get("type") == "structured":
                 items = structure.get("items", [])
                 if not any(item.get("type") == "value" for item in items):
                     continue
             else:
                 value_text = structure.get("value", "")
                 if isinstance(value_text, str):
                     if value_text.strip() == "":
                         continue
                 elif self._is_blank_result(value_text):
                     continue
             draw_test_header(test_name)
 
             def on_new_page():
                 draw_test_header(test_name)
 
             if structure.get("type") == "structured":
                 render_table_header(column_widths, on_new_page)
                 for item in structure.get("items", []):
                     if item.get("type") == "section":
                         render_section_row(item.get("label", ""), sum(column_widths), column_widths, on_new_page)
                         continue
                     row_texts = [
                         item.get('label', ''),
                         item.get('value', '-'),
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2556,63 +2750,68 @@ class MainWindow(QMainWindow):
             pdf.set_font("Arial", '', 6.9)
             pdf.multi_cell(0, 3.6, self._ensure_latin1(ord_inf['observations']))
             pdf.ln(1.5)
 
         try:
             pdf.output(file_path)
         except Exception as e:
             QMessageBox.warning(self, "Error", f"No se pudo guardar el PDF:\n{e}")
             return
         if mark_as_emitted:
             self.labdb.mark_order_emitted(order_id, emission_timestamp)
         QMessageBox.information(self, "Informe emitido", f"Reporte guardado en:\n{file_path}")
         self.populate_completed_orders()
         self.output_text.clear()
 
 
     def export_excel(self):
         # Exportar todos los resultados a un archivo CSV (Excel puede abrirlo)
         options = QFileDialog.Options()
         file_path, _ = QFileDialog.getSaveFileName(self, "Exportar datos", "", "Archivo CSV (*.csv)", options=options)
         if not file_path:
             return
         if not file_path.lower().endswith(".csv"):
             file_path += ".csv"
         self.labdb.cur.execute("""
-            SELECT p.first_name, p.last_name, p.doc_type, p.doc_number, t.name, ot.result, o.date, o.requested_by, o.diagnosis, o.age_years
+            SELECT p.first_name, p.last_name, p.doc_type, p.doc_number, p.sex, p.birth_date,
+                   t.name, ot.result, o.date, o.requested_by, o.diagnosis, o.age_years
             FROM order_tests ot
             JOIN orders o ON ot.order_id = o.id
             JOIN patients p ON o.patient_id = p.id
             JOIN tests t ON ot.test_id = t.id
         """)
         rows = self.labdb.cur.fetchall()
         try:
             with open(file_path, 'w', encoding='utf-8') as f:
                 f.write("Nombre,Apellidos,Documento,Prueba,Resultado,Fecha,Solicitante,Diagnostico presuntivo,Edad (años)\n")
-                for first, last, doc_type, doc_num, test_name, result, date, requester, diagnosis, age_years in rows:
+                for first, last, doc_type, doc_num, sex, birth_date, test_name, result, date, requester, diagnosis, age_years in rows:
                     name = (first or "").upper(); surn = (last or "").upper(); doc = f"{doc_type} {doc_num}".strip()
-                    res = self._format_result_for_export(test_name, result)
+                    context = {
+                        "patient": {"sex": sex, "birth_date": birth_date},
+                        "order": {"age_years": age_years}
+                    }
+                    res = self._format_result_for_export(test_name, result, context=context)
                     res = res.replace('"', "'")
                     dt = date
                     req = (requester or "").upper()
                     diag = (diagnosis or "").upper()
                     age_txt = str(age_years) if age_years is not None else ""
                     line = f"{name},{surn},{doc},{test_name},\"{res}\",{dt},{req},{diag},{age_txt}\n"
                     f.write(line)
             QMessageBox.information(self, "Exportado", f"Datos exportados a:\n{file_path}")
         except Exception as e:
             QMessageBox.warning(self, "Error", f"No se pudo exportar:\n{e}")
     def init_analisis_page(self):
         layout = QVBoxLayout(self.page_analisis)
         self.stats_label = QLabel()
         layout.addWidget(self.stats_label)
         self.stats_table = QTableWidget(0, 2)
         self.stats_table.setHorizontalHeaderLabels(["Categoría", "Cantidad"])
         layout.addWidget(self.stats_table)
         controls_layout = QHBoxLayout()
         controls_layout.addWidget(QLabel("Período:"))
         self.range_combo = QComboBox()
         self.range_combo.addItems([
             "Hoy",
             "Esta semana",
             "Este mes",
             "Últimos 30 días",
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2759,60 +2958,64 @@ class MainWindow(QMainWindow):
             description = f"Últimos 30 días ({start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')})"
         else:  # Rango personalizado
             if hasattr(self, 'start_date_edit') and hasattr(self, 'end_date_edit'):
                 start_q = self.start_date_edit.date()
                 end_q = self.end_date_edit.date()
                 if start_q.isValid():
                     start_date = datetime.date(start_q.year(), start_q.month(), start_q.day())
                 if end_q.isValid():
                     end_date = datetime.date(end_q.year(), end_q.month(), end_q.day())
             if end_date < start_date:
                 start_date, end_date = end_date, start_date
             description = f"Del {start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')}"
         start_dt = datetime.datetime.combine(start_date, datetime.time.min)
         end_dt = datetime.datetime.combine(end_date, datetime.time.max)
         return start_dt, end_dt, description
 
     def load_activity_summary(self):
         if not hasattr(self, 'activity_table'):
             return
         start_dt, end_dt, description = self._get_selected_range()
         rows = self.labdb.get_results_in_range(
             start_dt.strftime("%Y-%m-%d %H:%M:%S"),
             end_dt.strftime("%Y-%m-%d %H:%M:%S")
         )
         activity_data = []
-        for order_id, date_str, first, last, doc_type, doc_number, age_years, test_name, category, result in rows:
+        for order_id, date_str, first, last, doc_type, doc_number, sex, birth_date, age_years, test_name, category, result in rows:
             try:
                 order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
                 date_display = order_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 date_display = date_str or "-"
             patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
-            result_text = self._format_result_for_export(test_name, result).replace('\n', ' ')
+            context = {
+                "patient": {"sex": sex, "birth_date": birth_date},
+                "order": {"age_years": age_years}
+            }
+            result_text = self._format_result_for_export(test_name, result, context=context).replace('\n', ' ')
             if result_text.strip() == "":
                 continue
             activity_data.append({
                 "order_id": order_id,
                 "date": date_display,
                 "patient": patient_name,
                 "document": doc_text,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "category": category,
                 "emitted": None,
                 "emitted_at": None
             })
         self._activity_cache = {
             "data": activity_data,
             "description": description,
             "start": start_dt,
             "end": end_dt
         }
         self.activity_table.setRowCount(len(activity_data))
         for row_idx, item in enumerate(activity_data):
             self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
             order_item = QTableWidgetItem(str(item["order_id"]))
             order_item.setTextAlignment(Qt.AlignCenter)
diff --git a/main_window.py b/main_window.py
index 2a40040635d363f85c12b8bf6699c79bbb1e3212..e6901ae208ed1a9c602f796792a1fe76b68592a3 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2869,216 +3072,216 @@ class MainWindow(QMainWindow):
         aggregated = self._aggregate_results_by_order(data)
         if not aggregated:
             QMessageBox.information(self, "Sin datos", "No hay resultados con información para exportar en PDF.")
             return
         file_path, _ = QFileDialog.getSaveFileName(
             self,
             "Exportar registro",
             "registro.pdf",
             "Archivos PDF (*.pdf)"
         )
         if not file_path:
             return
         if not file_path.lower().endswith(".pdf"):
             file_path += ".pdf"
         pdf = FPDF('L', 'mm', 'A4')
         pdf.set_margins(12, 12, 12)
         pdf.set_auto_page_break(True, margin=14)
         pdf.add_page()
         pdf.set_font("Arial", 'B', 12)
         pdf.cell(0, 8, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
         pdf.set_font("Arial", '', 9)
         pdf.cell(0, 6, self._ensure_latin1(f"Registro de resultados - {description}"), ln=1, align='C')
         pdf.ln(2)
         headers = [
             "Fecha",
-            "Orden",
-            "Paciente",
             "Documento",
-            "Edad",
-            "Hematología",
-            "Bioquímica",
-            "Micro/Parasitología",
-            "Otros exámenes",
+            "Paciente",
+            "Pruebas realizadas",
             "Emitido"
         ]
-        column_widths = [27, 12, 44, 28, 12, 33, 33, 33, 30, 18]
+        column_widths = [28, 35, 52, 138, 20]
         pdf.set_fill_color(220, 220, 220)
-        pdf.set_font("Arial", 'B', 8.5)
+        pdf.set_font("Arial", 'B', 7.8)
         for header, width in zip(headers, column_widths):
             pdf.cell(width, 6, self._ensure_latin1(header), border=1, align='C', fill=True)
         pdf.ln(6)
 
         def ensure_space(required_height):
             if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
                 pdf.add_page()
                 pdf.set_font("Arial", 'B', 12)
                 pdf.cell(0, 8, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
                 pdf.set_font("Arial", '', 9)
                 pdf.cell(0, 6, self._ensure_latin1(f"Registro de resultados - {description}"), ln=1, align='C')
                 pdf.ln(2)
                 pdf.set_fill_color(220, 220, 220)
-                pdf.set_font("Arial", 'B', 8.5)
+                pdf.set_font("Arial", 'B', 7.8)
                 for header, width in zip(headers, column_widths):
                     pdf.cell(width, 6, self._ensure_latin1(header), border=1, align='C', fill=True)
                 pdf.ln(6)
-                pdf.set_font("Arial", '', 7.4)
+                pdf.set_font("Arial", '', 6.4)
 
         def wrap_cell_text(text, available_width):
             sanitized = self._ensure_latin1(str(text) if text not in (None, "") else "-")
             segments = []
             for part in sanitized.split('\n'):
                 part = part.strip()
                 if part:
                     segments.append(part)
             if not segments:
                 segments = [sanitized.strip() or "-"]
             lines = []
             for segment in segments:
                 words = segment.split()
                 if not words:
                     lines.append("-")
                     continue
                 current = words[0]
                 for word in words[1:]:
                     candidate = f"{current} {word}"
                     if pdf.get_string_width(candidate) <= max(available_width, 1):
                         current = candidate
                     else:
                         lines.append(current)
                         current = word
                 lines.append(current)
             return lines or ["-"]
 
         def render_row(texts):
-            line_height = 3.8
-            padding_x = 1.4
-            padding_y = 1.0
+            line_height = 3.0
+            padding_x = 1.2
+            padding_y = 0.8
             cell_lines = []
             max_lines = 1
             for idx, text in enumerate(texts):
                 available = max(column_widths[idx] - 2 * padding_x, 1)
                 lines = wrap_cell_text(text, available)
                 cell_lines.append(lines)
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             row_height = max_lines * line_height + 2 * padding_y
             ensure_space(row_height)
             x_start = pdf.l_margin
             y_start = pdf.get_y()
             pdf.set_draw_color(210, 215, 226)
             pdf.set_line_width(0.2)
             for idx, lines in enumerate(cell_lines):
                 cell_width = column_widths[idx]
                 x_pos = x_start + sum(column_widths[:idx])
                 pdf.rect(x_pos, y_start, cell_width, row_height)
                 text_y = y_start + padding_y
                 for line in lines:
                     pdf.set_xy(x_pos + padding_x, text_y)
                     pdf.cell(cell_width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
             pdf.set_xy(pdf.l_margin, y_start + row_height)
 
-        pdf.set_font("Arial", '', 7.4)
+        pdf.set_font("Arial", '', 6.4)
 
-        def format_group(entry, key):
-            values = entry.get("groups", {}).get(key, [])
+        def format_tests(entry):
+            values = []
+            for key in ("hematology", "biochemistry", "micro_parasito", "others"):
+                group_values = entry.get("groups", {}).get(key, [])
+                if group_values:
+                    values.extend(group_values)
             return "\n".join(values) if values else "-"
 
         for entry in aggregated:
-            cells = [
+            ordered_cells = [
                 entry.get("date", "-"),
-                str(entry.get("order_id", "-")),
-                entry.get("patient", "-"),
                 entry.get("document", "-"),
-                entry.get("age", "-"),
-                format_group(entry, "hematology"),
-                format_group(entry, "biochemistry"),
-                format_group(entry, "micro_parasito"),
-                format_group(entry, "others"),
+                entry.get("patient", "-"),
+                format_tests(entry),
                 self._format_emission_status(entry.get("emitted"), entry.get("emitted_at"))
             ]
-            render_row(cells)
+            render_row(ordered_cells)
         try:
             pdf.output(file_path)
         except Exception as exc:
             QMessageBox.warning(self, "Error", f"No se pudo generar el PDF:\n{exc}")
             return
         QMessageBox.information(self, "Exportado", f"Registro guardado en:\n{file_path}")
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
 
     def _on_history_selection_changed(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         has_selection = bool(selection.selectedRows()) if selection else False
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(has_selection)
 
     def search_patient_history(self):
         if not hasattr(self, 'history_table'):
             return
         doc_number = self.history_doc_input.text().strip() if hasattr(self, 'history_doc_input') else ""
         if doc_number == "":
             QMessageBox.warning(self, "DNI requerido", "Ingrese un DNI para realizar la búsqueda.")
             return
         if not doc_number.isdigit():
             QMessageBox.warning(self, "Formato inválido", "El DNI debe contener solo números.")
             return
         self._clear_history_table()
         rows = self.labdb.get_patient_history_by_document(doc_number, "DNI")
         records = []
         for row in rows:
             (
                 order_id,
                 date_str,
                 test_name,
                 raw_result,
                 category,
                 first_name,
                 last_name,
                 doc_type,
                 doc_value,
+                sex,
+                birth_date,
                 age_years,
                 emitted,
                 emitted_at
             ) = row
             try:
                 order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
                 date_display = order_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 date_display = date_str or "-"
             patient_name = " ".join(part for part in [(first_name or "").upper(), (last_name or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_value) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
-            result_text = self._format_result_for_export(test_name, raw_result).replace('\n', ' ')
+            context = {
+                "patient": {"sex": sex, "birth_date": birth_date},
+                "order": {"age_years": age_years}
+            }
+            result_text = self._format_result_for_export(test_name, raw_result, context=context).replace('\n', ' ')
             if result_text.strip() == "":
                 continue
             records.append({
                 "order_id": order_id,
                 "date": date_display,
                 "patient": patient_name,
                 "document": doc_text,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "category": category,
                 "emitted": emitted,
                 "emitted_at": emitted_at
             })
         aggregated = self._aggregate_results_by_order(records)
         self._history_results = aggregated
         self.history_table.setRowCount(len(aggregated))
         headers = [
             "date",
             "order_id",
             "patient",
             "document",
             "age",
             "hematology",
             "biochemistry",
