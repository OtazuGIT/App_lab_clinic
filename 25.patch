diff --git a/main_window.py b/main_window.py
index 3e0c369a2b9b65210adb84a79b9d6e86684e7b0b..c0c9b940049f1936af108936d660f12896f17def 100644
--- a/main_window.py
+++ b/main_window.py
@@ -4476,181 +4476,186 @@ class MainWindow(QMainWindow):
             ]
             render_row(ordered_cells)
         cache = getattr(self, '_activity_cache', {})
         report_start = cache.get("start")
         report_end = cache.get("end")
         if report_start and report_end:
             try:
                 start_date = report_start.date() if isinstance(report_start, datetime.datetime) else report_start
                 end_date = report_end.date() if isinstance(report_end, datetime.datetime) else report_end
             except AttributeError:
                 start_date = end_date = None
             if start_date and end_date and start_date == end_date:
                 self._append_delivery_sheet(pdf, aggregated, start_date)
         try:
             pdf.output(file_path)
         except Exception as exc:
             QMessageBox.warning(self, "Error", f"No se pudo generar el PDF:\n{exc}")
             return
         QMessageBox.information(self, "Exportado", f"Registro guardado en:\n{file_path}")
 
     def _append_delivery_sheet(self, pdf, aggregated, report_date):
         if not aggregated:
             return
         prev_left, prev_top, prev_right, prev_bottom = pdf.l_margin, pdf.t_margin, pdf.r_margin, pdf.b_margin
         prev_auto = pdf.auto_page_break
-        pdf.set_margins(6, 10, 6)
-        pdf.set_auto_page_break(True, margin=10)
-        self._add_pdf_page(pdf, orientation='L', page_format='A5')
+        pdf.set_margins(10, 14, 10)
+        pdf.set_auto_page_break(True, margin=12)
+        self._add_pdf_page(pdf, orientation='L', page_format='A4')
         pdf.set_font("Arial", 'B', 11)
         pdf.cell(0, 6, self._ensure_latin1("Entrega de resultados"), ln=1, align='C')
         base_date = report_date
         if isinstance(base_date, datetime.datetime):
             base_date = base_date.date()
         if not base_date:
             base_date = datetime.date.today()
         pdf.set_font("Arial", '', 9)
         pdf.cell(
             0,
             5,
             self._ensure_latin1(f"Listado de pacientes - {base_date.strftime('%d/%m/%Y')}"),
             ln=1,
             align='C'
         )
         pdf.ln(1.5)
+        available_width = max(pdf.w - pdf.l_margin - pdf.r_margin, 0)
         columns = [
-            {"title": "Fecha de entrega", "width": 24, "min_lines": 1},
-            {"title": "Paciente", "width": 42, "min_lines": 2},
-            {"title": "Pruebas entregadas", "width": 58, "min_lines": 2},
-            {"title": "Entregado por", "width": 34, "min_lines": 2},
-            {"title": "Personal que recibe / Observaciones", "width": 40, "min_lines": 3},
+            {"title": "Fecha de entrega", "ratio": 0.16, "min_lines": 1},
+            {"title": "Paciente", "ratio": 0.22, "min_lines": 2},
+            {"title": "Pruebas entregadas", "ratio": 0.26, "min_lines": 2},
+            {"title": "Entregado por", "ratio": 0.16, "min_lines": 2},
+            {"title": "Personal que recibe / Observaciones", "ratio": 0.20, "min_lines": 3},
+        ]
+        column_widths = [
+            max(available_width * column["ratio"], 22) for column in columns
         ]
         padding_x = 1.2
         padding_y = 1.0
         line_height = 4.0
 
         def wrap_text(value, available_width, min_lines=1):
             base_text = ""
             if value not in (None, ""):
                 base_text = self._ensure_latin1(str(value))
             segments = [seg.strip() for seg in base_text.split('\n') if seg.strip()]
             if not segments:
                 segments = [""]
             lines = []
             for segment in segments:
                 words = segment.split()
                 if not words:
                     lines.append("")
                     continue
                 current = words[0]
                 for word in words[1:]:
                     candidate = f"{current} {word}"
                     if pdf.get_string_width(candidate) <= max(available_width, 1):
                         current = candidate
                     else:
                         lines.append(current)
                         current = word
                 lines.append(current)
             if not lines:
                 lines = [""]
             while len(lines) < min_lines:
                 lines.append("")
             return lines
 
         pdf.set_draw_color(180, 180, 180)
         pdf.set_line_width(0.2)
         pdf.set_font("Arial", 'B', 7.6)
         header_lines = []
         max_header_lines = 1
-        for column in columns:
-            text_lines = wrap_text(column["title"], column["width"] - 2 * padding_x, 1)
+        for idx, column in enumerate(columns):
+            column_width = column_widths[idx]
+            text_lines = wrap_text(column["title"], column_width - 2 * padding_x, 1)
             header_lines.append(text_lines)
             if len(text_lines) > max_header_lines:
                 max_header_lines = len(text_lines)
         header_height = max_header_lines * line_height + 2 * padding_y
         start_x = pdf.l_margin
         start_y = pdf.get_y()
         pdf.set_fill_color(210, 210, 210)
         for idx, column in enumerate(columns):
-            width = column["width"]
+            width = column_widths[idx]
             pdf.rect(start_x, start_y, width, header_height, style='DF')
             text_y = start_y + padding_y
             for line in header_lines[idx]:
                 pdf.set_xy(start_x + padding_x, text_y)
                 pdf.cell(width - 2 * padding_x, line_height, line, border=0)
                 text_y += line_height
             start_x += width
         pdf.set_xy(pdf.l_margin, start_y + header_height)
         pdf.set_font("Arial", '', 7.2)
         deliverer_info = self._format_user_identity_for_delivery()
         for entry in aggregated:
             cell_values = [
                 entry.get("date") or base_date.strftime("%d/%m/%Y"),
                 entry.get("patient", "-"),
                 "\n".join(entry.get("tests", [])) if entry.get("tests") else "-",
                 deliverer_info,
                 ""
             ]
             wrapped = []
             max_lines = 1
-            for column, value in zip(columns, cell_values):
-                lines = wrap_text(value, column["width"] - 2 * padding_x, column["min_lines"])
+            for column, width, value in zip(columns, column_widths, cell_values):
+                lines = wrap_text(value, width - 2 * padding_x, column["min_lines"])
                 wrapped.append(lines)
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             row_height = max_lines * line_height + 2 * padding_y
             if pdf.get_y() + row_height > pdf.h - pdf.b_margin:
-                self._add_pdf_page(pdf, orientation='L', page_format='A5')
+                self._add_pdf_page(pdf, orientation='L', page_format='A4')
                 pdf.set_font("Arial", 'B', 11)
                 pdf.cell(0, 6, self._ensure_latin1("Entrega de resultados"), ln=1, align='C')
                 pdf.set_font("Arial", '', 9)
                 pdf.cell(
                     0,
                     5,
                     self._ensure_latin1(f"Listado de pacientes - {base_date.strftime('%d/%m/%Y')}"),
                     ln=1,
                     align='C'
                 )
                 pdf.ln(1.5)
                 pdf.set_font("Arial", 'B', 7.6)
                 start_x = pdf.l_margin
                 start_y = pdf.get_y()
                 for idx, column in enumerate(columns):
-                    width = column["width"]
+                    width = column_widths[idx]
                     pdf.rect(start_x, start_y, width, header_height, style='DF')
                     text_y = start_y + padding_y
                     for line in header_lines[idx]:
                         pdf.set_xy(start_x + padding_x, text_y)
                         pdf.cell(width - 2 * padding_x, line_height, line, border=0)
                         text_y += line_height
                     start_x += width
                 pdf.set_xy(pdf.l_margin, start_y + header_height)
                 pdf.set_font("Arial", '', 7.2)
             row_start_x = pdf.l_margin
             row_start_y = pdf.get_y()
             for idx, column in enumerate(columns):
-                width = column["width"]
+                width = column_widths[idx]
                 pdf.rect(row_start_x, row_start_y, width, row_height)
                 text_y = row_start_y + padding_y
                 for line in wrapped[idx]:
                     pdf.set_xy(row_start_x + padding_x, text_y)
                     pdf.cell(width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
                 row_start_x += width
             pdf.set_xy(pdf.l_margin, row_start_y + row_height)
         pdf.set_margins(prev_left, prev_top, prev_right)
         pdf.set_auto_page_break(prev_auto, margin=prev_bottom)
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
 
     def _on_history_selection_changed(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         has_selection = bool(selection.selectedRows()) if selection else False
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(has_selection)
