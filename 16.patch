diff --git a/main_window.py b/main_window.py
index 35b8ebc06910d164f33888ec7504abd494b18b49..223194fb41348238812b5c65d2d9922fedfac649 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2882,110 +2882,110 @@ class MainWindow(QMainWindow):
         self.include_emitted_checkbox.toggled.connect(self.populate_completed_orders)
         self.completed_sort_combo.currentIndexChanged.connect(lambda: self._refresh_completed_combo())
     def populate_completed_orders(self):
         # Llenar combo de órdenes completadas
         include_emitted = False
         if hasattr(self, 'include_emitted_checkbox'):
             include_emitted = self.include_emitted_checkbox.isChecked()
         completed_rows = self.labdb.get_completed_orders(include_emitted=include_emitted)
         self.completed_orders_cache = []
         for row in completed_rows:
             oid, first, last, date, doc_type, doc_number, emitted, emitted_at = row
             order = {
                 "id": oid,
                 "first_name": (first or "").upper(),
                 "last_name": (last or "").upper(),
                 "date": date,
                 "doc_type": doc_type or "",
                 "doc_number": doc_number or "",
                 "emitted": bool(emitted),
                 "emitted_at": emitted_at
             }
             self.completed_orders_cache.append(order)
         self._refresh_completed_combo()
 
 
-def delete_order_from_results(self):
-    if not hasattr(self, 'combo_orders'):
-        return
-    data = self.combo_orders.currentData()
-    if data is None:
-        QMessageBox.information(self, "Sin selección", "Seleccione una orden pendiente para eliminar.")
-        return
-    self._confirm_delete_order(int(data))
-
-def delete_order_from_emission(self):
-    if not hasattr(self, 'combo_completed'):
-        return
-    data = self.combo_completed.currentData()
-    if data is None:
-        QMessageBox.information(self, "Sin selección", "Seleccione una orden completada para eliminar.")
-        return
-    self._confirm_delete_order(int(data))
-
-def _confirm_delete_order(self, order_id):
-    if not order_id:
-        return
-    info = self.labdb.get_order_details(order_id)
-    if not info:
-        QMessageBox.warning(self, "Orden no disponible", "La orden seleccionada ya no está disponible.")
-        self.populate_pending_orders()
-        self.populate_completed_orders()
-        return
-    pat = info.get("patient", {})
-    ord_inf = info.get("order", {})
-    patient_name = pat.get("name") or "-"
-    confirm = QMessageBox.question(
-        self,
-        "Eliminar orden",
-        f"¿Desea eliminar la orden #{order_id} asociada a {patient_name}?",
-        QMessageBox.Yes | QMessageBox.No
-    )
-    if confirm == QMessageBox.No:
-        return
-    dialog = ReasonDialog(
-        "Motivo de eliminación",
-        "Indique el motivo por el que se elimina la orden.",
-        self,
-        placeholder="Motivo (ej. duplicado, prueba, error de digitación)"
-    )
-    dialog.text_edit.setPlainText("Duplicidad de registro")
-    if dialog.exec_() != QDialog.Accepted:
-        return
-    reason = dialog.get_reason() or "Sin motivo"
-    deleted = self.labdb.mark_order_deleted(order_id, reason, self.user.get('id'))
-    if deleted:
-        QMessageBox.information(self, "Orden eliminada", f"La orden #{order_id} fue eliminada correctamente.")
-        if getattr(self, 'selected_order_id', None) == order_id:
-            self.selected_order_id = None
-        self.populate_pending_orders()
-        self.populate_completed_orders()
-        self.load_activity_summary()
-        self.output_text.clear()
-        self._clear_results_layout()
-    else:
-        QMessageBox.warning(self, "Sin cambios", "No se pudo eliminar la orden seleccionada.")
+    def delete_order_from_results(self):
+        if not hasattr(self, 'combo_orders'):
+            return
+        data = self.combo_orders.currentData()
+        if data is None:
+            QMessageBox.information(self, "Sin selección", "Seleccione una orden pendiente para eliminar.")
+            return
+        self._confirm_delete_order(int(data))
+
+    def delete_order_from_emission(self):
+        if not hasattr(self, 'combo_completed'):
+            return
+        data = self.combo_completed.currentData()
+        if data is None:
+            QMessageBox.information(self, "Sin selección", "Seleccione una orden completada para eliminar.")
+            return
+        self._confirm_delete_order(int(data))
+
+    def _confirm_delete_order(self, order_id):
+        if not order_id:
+            return
+        info = self.labdb.get_order_details(order_id)
+        if not info:
+            QMessageBox.warning(self, "Orden no disponible", "La orden seleccionada ya no está disponible.")
+            self.populate_pending_orders()
+            self.populate_completed_orders()
+            return
+        pat = info.get("patient", {})
+        ord_inf = info.get("order", {})
+        patient_name = pat.get("name") or "-"
+        confirm = QMessageBox.question(
+            self,
+            "Eliminar orden",
+            f"¿Desea eliminar la orden #{order_id} asociada a {patient_name}?",
+            QMessageBox.Yes | QMessageBox.No
+        )
+        if confirm == QMessageBox.No:
+            return
+        dialog = ReasonDialog(
+            "Motivo de eliminación",
+            "Indique el motivo por el que se elimina la orden.",
+            self,
+            placeholder="Motivo (ej. duplicado, prueba, error de digitación)"
+        )
+        dialog.text_edit.setPlainText("Duplicidad de registro")
+        if dialog.exec_() != QDialog.Accepted:
+            return
+        reason = dialog.get_reason() or "Sin motivo"
+        deleted = self.labdb.mark_order_deleted(order_id, reason, self.user.get('id'))
+        if deleted:
+            QMessageBox.information(self, "Orden eliminada", f"La orden #{order_id} fue eliminada correctamente.")
+            if getattr(self, 'selected_order_id', None) == order_id:
+                self.selected_order_id = None
+            self.populate_pending_orders()
+            self.populate_completed_orders()
+            self.load_activity_summary()
+            self.output_text.clear()
+            self._clear_results_layout()
+        else:
+            QMessageBox.warning(self, "Sin cambios", "No se pudo eliminar la orden seleccionada.")
 
     def add_tests_to_selected_order(self):
         data = self.combo_completed.currentData() if hasattr(self, 'combo_completed') else None
         if data is None:
             QMessageBox.information(self, "Sin selección", "Seleccione una orden para agregar pruebas adicionales.")
             return
         order_id = int(data)
         all_tests = self.labdb.get_all_tests()
         existing = self.labdb.get_tests_for_order(order_id)
         dialog = AddTestsDialog(all_tests, existing, self)
         if dialog.exec_() != QDialog.Accepted:
             return
         selected = dialog.get_selected_tests()
         if not selected:
             QMessageBox.information(self, "Sin cambios", "No se seleccionaron nuevas pruebas.")
             return
         added = self.labdb.add_tests_to_order(order_id, selected)
         if not added:
             QMessageBox.information(self, "Sin cambios", "Las pruebas seleccionadas ya estaban asociadas a la orden.")
             return
         QMessageBox.information(
             self,
             "Pruebas agregadas",
             "Se agregaron {0} prueba(s). Registre los resultados antes de emitir nuevamente.".format(len(added))
         )
diff --git a/main_window.py b/main_window.py
index 35b8ebc06910d164f33888ec7504abd494b18b49..223194fb41348238812b5c65d2d9922fedfac649 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3669,155 +3669,155 @@ def _confirm_delete_order(self, order_id):
                 next_month = datetime.date(start_date.year + 1, 1, 1)
             else:
                 next_month = datetime.date(start_date.year, start_date.month + 1, 1)
             end_date = next_month - datetime.timedelta(days=1)
             description = f"Mes del {start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')}"
         elif idx == 3:  # Últimos 30 días
             start_date = today - datetime.timedelta(days=29)
             end_date = today
             description = f"Últimos 30 días ({start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')})"
         else:  # Rango personalizado
             if hasattr(self, 'start_date_edit') and hasattr(self, 'end_date_edit'):
                 start_q = self.start_date_edit.date()
                 end_q = self.end_date_edit.date()
                 if start_q.isValid():
                     start_date = datetime.date(start_q.year(), start_q.month(), start_q.day())
                 if end_q.isValid():
                     end_date = datetime.date(end_q.year(), end_q.month(), end_q.day())
             if end_date < start_date:
                 start_date, end_date = end_date, start_date
             description = f"Del {start_date.strftime('%d/%m/%Y')} al {end_date.strftime('%d/%m/%Y')}"
         start_dt = datetime.datetime.combine(start_date, datetime.time.min)
         end_dt = datetime.datetime.combine(end_date, datetime.time.max)
         return start_dt, end_dt, description
 
 
-def load_activity_summary(self):
-    if not hasattr(self, 'activity_table'):
-        return
-    start_dt, end_dt, description = self._get_selected_range()
-    rows = self.labdb.get_results_in_range(
-        start_dt.strftime("%Y-%m-%d %H:%M:%S"),
-        end_dt.strftime("%Y-%m-%d %H:%M:%S")
-    )
-    activity_data = []
-    for (
-        test_entry_id,
-        order_id,
-        date_str,
-        sample_date_str,
-        first,
-        last,
-        doc_type,
-        doc_number,
-        sex,
-        birth_date,
-        hcl,
-        age_years,
-        order_obs,
-        test_name,
-        category,
-        result,
-        sample_status,
-        sample_issue,
-        observation
-    ) in rows:
-        display_date = "-"
-        if sample_date_str:
-            try:
-                sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
-                display_date = sample_dt.strftime("%d/%m/%Y")
-            except Exception:
-                display_date = sample_date_str
-        if display_date == "-":
-            try:
-                order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
-                display_date = order_dt.strftime("%d/%m/%Y %H:%M")
-            except Exception:
-                display_date = date_str or "-"
-        patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
-        doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
-        age_display = str(age_years) if age_years not in (None, "") else "-"
-        context = {
-            "patient": {"sex": sex, "birth_date": birth_date},
-            "order": {"age_years": age_years}
-        }
-        summary_items = self._build_registry_summary(test_name, result, context=context)
-        if not summary_items:
-            continue
-        result_text = "; ".join(summary_items)
-        activity_data.append({
-            "entry_id": test_entry_id,
-            "order_id": order_id,
-            "date": display_date,
-            "order_date_raw": date_str,
-            "sample_date_raw": sample_date_str,
-            "patient": patient_name,
-            "document": doc_text,
-            "doc_type": doc_type,
-            "doc_number": doc_number,
-            "birth_date": birth_date,
-            "hcl": hcl,
-            "age": age_display,
-            "test": test_name,
-            "result": result_text,
-            "summary_items": summary_items,
-            "category": category,
-            "order_observations": order_obs,
-            "emitted": None,
-            "emitted_at": None,
-            "first_name": first,
-            "last_name": last,
-            "sample_status": sample_status,
-            "sample_issue": sample_issue,
-            "observation": observation
-        })
-    self._activity_cache = {
-        "data": activity_data,
-        "description": description,
-        "start": start_dt,
-        "end": end_dt
-    }
-    self.activity_table.setRowCount(len(activity_data))
-    for row_idx, item in enumerate(activity_data):
-        self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
-        order_item = QTableWidgetItem(str(item["order_id"]))
-        order_item.setTextAlignment(Qt.AlignCenter)
-        self.activity_table.setItem(row_idx, 1, order_item)
-        self.activity_table.setItem(row_idx, 2, QTableWidgetItem(item["patient"]))
-        self.activity_table.setItem(row_idx, 3, QTableWidgetItem(item["document"]))
-        age_item = QTableWidgetItem(item["age"])
-        age_item.setTextAlignment(Qt.AlignCenter)
-        self.activity_table.setItem(row_idx, 4, age_item)
-        self.activity_table.setItem(row_idx, 5, QTableWidgetItem(item["test"]))
-        status_text = self._format_sample_status_text(item.get("sample_status"), item.get("sample_issue"))
-        self.activity_table.setItem(row_idx, 6, QTableWidgetItem(status_text or "-"))
-        self.activity_table.setItem(row_idx, 7, QTableWidgetItem(item["result"]))
-    if hasattr(self, 'activity_caption'):
-        self.activity_caption.setText(
-            f"Registro de pruebas: {description} - {len(activity_data)} resultado(s)"
+    def load_activity_summary(self):
+        if not hasattr(self, 'activity_table'):
+            return
+        start_dt, end_dt, description = self._get_selected_range()
+        rows = self.labdb.get_results_in_range(
+            start_dt.strftime("%Y-%m-%d %H:%M:%S"),
+            end_dt.strftime("%Y-%m-%d %H:%M:%S")
         )
+        activity_data = []
+        for (
+            test_entry_id,
+            order_id,
+            date_str,
+            sample_date_str,
+            first,
+            last,
+            doc_type,
+            doc_number,
+            sex,
+            birth_date,
+            hcl,
+            age_years,
+            order_obs,
+            test_name,
+            category,
+            result,
+            sample_status,
+            sample_issue,
+            observation
+        ) in rows:
+            display_date = "-"
+            if sample_date_str:
+                try:
+                    sample_dt = datetime.datetime.strptime(sample_date_str, "%Y-%m-%d")
+                    display_date = sample_dt.strftime("%d/%m/%Y")
+                except Exception:
+                    display_date = sample_date_str
+            if display_date == "-":
+                try:
+                    order_dt = datetime.datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
+                    display_date = order_dt.strftime("%d/%m/%Y %H:%M")
+                except Exception:
+                    display_date = date_str or "-"
+            patient_name = " ".join(part for part in [(first or "").upper(), (last or "").upper()] if part).strip() or "-"
+            doc_text = " ".join(part for part in (doc_type, doc_number) if part).strip() or "-"
+            age_display = str(age_years) if age_years not in (None, "") else "-"
+            context = {
+                "patient": {"sex": sex, "birth_date": birth_date},
+                "order": {"age_years": age_years}
+            }
+            summary_items = self._build_registry_summary(test_name, result, context=context)
+            if not summary_items:
+                continue
+            result_text = "; ".join(summary_items)
+            activity_data.append({
+                "entry_id": test_entry_id,
+                "order_id": order_id,
+                "date": display_date,
+                "order_date_raw": date_str,
+                "sample_date_raw": sample_date_str,
+                "patient": patient_name,
+                "document": doc_text,
+                "doc_type": doc_type,
+                "doc_number": doc_number,
+                "birth_date": birth_date,
+                "hcl": hcl,
+                "age": age_display,
+                "test": test_name,
+                "result": result_text,
+                "summary_items": summary_items,
+                "category": category,
+                "order_observations": order_obs,
+                "emitted": None,
+                "emitted_at": None,
+                "first_name": first,
+                "last_name": last,
+                "sample_status": sample_status,
+                "sample_issue": sample_issue,
+                "observation": observation
+            })
+        self._activity_cache = {
+            "data": activity_data,
+            "description": description,
+            "start": start_dt,
+            "end": end_dt
+        }
+        self.activity_table.setRowCount(len(activity_data))
+        for row_idx, item in enumerate(activity_data):
+            self.activity_table.setItem(row_idx, 0, QTableWidgetItem(item["date"]))
+            order_item = QTableWidgetItem(str(item["order_id"]))
+            order_item.setTextAlignment(Qt.AlignCenter)
+            self.activity_table.setItem(row_idx, 1, order_item)
+            self.activity_table.setItem(row_idx, 2, QTableWidgetItem(item["patient"]))
+            self.activity_table.setItem(row_idx, 3, QTableWidgetItem(item["document"]))
+            age_item = QTableWidgetItem(item["age"])
+            age_item.setTextAlignment(Qt.AlignCenter)
+            self.activity_table.setItem(row_idx, 4, age_item)
+            self.activity_table.setItem(row_idx, 5, QTableWidgetItem(item["test"]))
+            status_text = self._format_sample_status_text(item.get("sample_status"), item.get("sample_issue"))
+            self.activity_table.setItem(row_idx, 6, QTableWidgetItem(status_text or "-"))
+            self.activity_table.setItem(row_idx, 7, QTableWidgetItem(item["result"]))
+        if hasattr(self, 'activity_caption'):
+            self.activity_caption.setText(
+                f"Registro de pruebas: {description} - {len(activity_data)} resultado(s)"
+            )
 
 
     def delete_selected_activity_entries(self):
         if not hasattr(self, 'activity_table'):
             return
         selected = self.activity_table.selectionModel().selectedRows() if self.activity_table.selectionModel() else []
         if not selected:
             QMessageBox.information(self, "Sin selección", "Seleccione al menos un resultado para eliminar.")
             return
         if not getattr(self, '_activity_cache', None):
             self.load_activity_summary()
         cache = getattr(self, '_activity_cache', {"data": []})
         entries = cache.get("data", [])
         selected_ids = []
         for model_index in selected:
             row = model_index.row()
             if 0 <= row < len(entries):
                 entry = entries[row]
                 entry_id = entry.get("entry_id")
                 if entry_id:
                     selected_ids.append(entry_id)
         if not selected_ids:
             QMessageBox.warning(self, "Sin datos", "No se pudo identificar los registros seleccionados.")
             return
         dialog = ReasonDialog(
