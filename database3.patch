diff --git a/database.py b/database.py
index 349aef25dd200cb259987f60ceb6a7bfb7ae8c23..9666ee7b4fc86dedbba70212b5515cf6c7289c78 100644
--- a/database.py
+++ b/database.py
@@ -42,50 +42,52 @@ class LabDB:
         self.cur.execute("""
             CREATE TABLE IF NOT EXISTS tests (
                 id INTEGER PRIMARY KEY AUTOINCREMENT,
                 name TEXT,
                 category TEXT
             )
         """)
         self.cur.execute("""
             CREATE TABLE IF NOT EXISTS orders (
                 id INTEGER PRIMARY KEY AUTOINCREMENT,
                 patient_id INTEGER,
                 date TEXT,
                 created_by INTEGER,
                 observations TEXT,
                 requested_by TEXT,
                 diagnosis TEXT,
                 age_years INTEGER,
                 completed INTEGER DEFAULT 0,
                 FOREIGN KEY(patient_id) REFERENCES patients(id),
                 FOREIGN KEY(created_by) REFERENCES users(id)
             )
         """)
         # Asegurarse de que columnas nuevas existan para bases de datos creadas anteriormente
         self._ensure_column_exists("orders", "diagnosis", "TEXT", default_value="")
         self._ensure_column_exists("orders", "age_years", "INTEGER")
+        self._ensure_column_exists("orders", "emitted", "INTEGER", default_value="0")
+        self._ensure_column_exists("orders", "emitted_at", "TEXT")
         self.cur.execute("""
             CREATE TABLE IF NOT EXISTS order_tests (
                 id INTEGER PRIMARY KEY AUTOINCREMENT,
                 order_id INTEGER,
                 test_id INTEGER,
                 result TEXT,
                 FOREIGN KEY(order_id) REFERENCES orders(id),
                 FOREIGN KEY(test_id) REFERENCES tests(id)
             )
         """)
         self.conn.commit()
         # Datos iniciales por defecto
         self.cur.execute("SELECT COUNT(*) FROM users")
         if self.cur.fetchone()[0] == 0:
             # Crear usuario admin por defecto
             self.cur.execute("INSERT INTO users(username, password, role) VALUES (?,?,?)",
                              ("admin", "admin", "super"))
             self.conn.commit()
         self.cur.execute("SELECT COUNT(*) FROM tests")
         if self.cur.fetchone()[0] == 0:
             tests_by_category = {
                 "HEMATOLOGÍA": [
                     "Lámina periférica", "Hemograma manual", "Hemograma automatizado",
                     "Hemoglobina", "Hematocrito", "Recuento de leucocitos", "Recuento de hematíes",
                     "Recuento de plaquetas", "Constantes corpusculares", "Células LE",
diff --git a/database.py b/database.py
index 349aef25dd200cb259987f60ceb6a7bfb7ae8c23..9666ee7b4fc86dedbba70212b5515cf6c7289c78 100644
--- a/database.py
+++ b/database.py
@@ -191,97 +193,111 @@ class LabDB:
             INSERT INTO orders(patient_id, date, created_by, observations, requested_by, diagnosis, age_years, completed)
             VALUES (?,?,?,?,?,?,?,?)
         """, (patient_id, date_str, user_id, observations, requested_by, diagnosis, age_value, 0))
         order_id = self.cur.lastrowid
         for name in test_names:
             if name in self.test_map:
                 test_id = self.test_map[name]
                 self.cur.execute("INSERT INTO order_tests(order_id, test_id, result) VALUES (?,?,?)",
                                  (order_id, test_id, ""))
         self.conn.commit()
         return order_id
     def get_pending_orders(self):
         self.cur.execute("""
             SELECT o.id, p.first_name, p.last_name, o.date, p.doc_type, p.doc_number
             FROM orders o
             JOIN patients p ON o.patient_id=p.id
             WHERE o.completed=0
             ORDER BY o.date ASC, o.id ASC
         """)
         return self.cur.fetchall()
     def get_completed_orders(self):
         self.cur.execute("""
             SELECT o.id, p.first_name, p.last_name, o.date, p.doc_type, p.doc_number
             FROM orders o
             JOIN patients p ON o.patient_id=p.id
-            WHERE o.completed=1
+            WHERE o.completed=1 AND (o.emitted IS NULL OR o.emitted=0)
             ORDER BY o.date ASC, o.id ASC
         """)
         return self.cur.fetchall()
     def get_order_details(self, order_id):
         self.cur.execute("""
             SELECT p.first_name, p.last_name, p.doc_type, p.doc_number, p.birth_date, p.sex, p.origin, p.hcl,
-                   o.date, o.observations, o.requested_by, o.diagnosis, o.age_years,
+                   o.date, o.observations, o.requested_by, o.diagnosis, o.age_years, o.emitted, o.emitted_at,
                    t.name, ot.result
             FROM orders o
             JOIN patients p ON o.patient_id = p.id
             JOIN order_tests ot ON ot.order_id = o.id
             JOIN tests t ON ot.test_id = t.id
             WHERE o.id = ?
         """, (order_id,))
         rows = self.cur.fetchall()
         if not rows:
             return None
-        first_name, last_name, doc_type, doc_number, birth_date, sex, origin, hcl, date, obs, req_by, diag, age_years, _, _ = rows[0]
+        first_name, last_name, doc_type, doc_number, birth_date, sex, origin, hcl, date, obs, req_by, diag, age_years, emitted, emitted_at, _, _ = rows[0]
         patient_info = {
             "name": f"{first_name} {last_name}",
             "doc_type": doc_type,
             "doc_number": doc_number,
             "birth_date": birth_date,
             "sex": sex,
             "origin": origin,
             "hcl": hcl
         }
-        order_info = {"date": date, "observations": obs, "requested_by": req_by, "diagnosis": diag, "age_years": age_years}
+        order_info = {
+            "date": date,
+            "observations": obs,
+            "requested_by": req_by,
+            "diagnosis": diag,
+            "age_years": age_years,
+            "emitted": emitted,
+            "emitted_at": emitted_at,
+        }
         results = [(row[12], row[13]) for row in rows]
         return {"patient": patient_info, "order": order_info, "results": results}
     def save_results(self, order_id, results_dict):
         for name, result in results_dict.items():
             if name in self.test_map:
                 tid = self.test_map[name]
                 if isinstance(result, dict):
                     stored = json.dumps(result, ensure_ascii=False)
                 else:
                     stored = result
                 self.cur.execute(
                     "UPDATE order_tests SET result=? WHERE order_id=? AND test_id=?",
                     (stored, order_id, tid)
                 )
         # Verificar si quedan resultados vacíos
         self.cur.execute("SELECT COUNT(*) FROM order_tests WHERE order_id=? AND (result IS NULL OR result='')", (order_id,))
         remaining = self.cur.fetchone()[0]
         completed_flag = 1 if remaining == 0 else 0
         self.cur.execute("UPDATE orders SET completed=? WHERE id=?", (completed_flag, order_id))
         self.conn.commit()
         return completed_flag
+    def mark_order_emitted(self, order_id, emitted_at):
+        self.cur.execute(
+            "UPDATE orders SET emitted=1, emitted_at=? WHERE id=?",
+            (emitted_at, order_id)
+        )
+        self.conn.commit()
     def get_statistics(self):
         stats = {}
         self.cur.execute("SELECT COUNT(*) FROM patients"); stats["total_patients"] = self.cur.fetchone()[0]
         self.cur.execute("SELECT COUNT(*) FROM orders"); stats["total_orders"] = self.cur.fetchone()[0]
         self.cur.execute("SELECT COUNT(*) FROM order_tests"); stats["total_tests_conducted"] = self.cur.fetchone()[0]
         self.cur.execute("""
             SELECT t.category, COUNT(*) FROM order_tests ot JOIN tests t ON ot.test_id = t.id GROUP BY t.category
         """)
         stats["by_category"] = self.cur.fetchall()
         return stats
     def get_distinct_requesters(self):
         self.cur.execute("SELECT DISTINCT requested_by FROM orders WHERE requested_by IS NOT NULL AND requested_by<>'' ORDER BY requested_by")
         return [row[0] for row in self.cur.fetchall() if row[0]]
     def _ensure_column_exists(self, table_name, column_name, column_type, default_value=None):
         self.cur.execute(f"PRAGMA table_info({table_name})")
         columns = [info[1] for info in self.cur.fetchall()]
         if column_name not in columns:
             alter_sql = f"ALTER TABLE {table_name} ADD COLUMN {column_name} {column_type}"
             if default_value is not None:
                 alter_sql += f" DEFAULT '{default_value}'"
             self.cur.execute(alter_sql)
             self.conn.commit()
