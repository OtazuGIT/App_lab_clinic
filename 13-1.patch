diff --git a/main_window.py b/main_window.py
index 727968e063294b4dcf0ab2f5b3b35893b6ab4e69..1f5c34682cab2af09e8a011fb06420e714ee6155 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1,47 +1,49 @@
 # main_window.py
 import copy
 import datetime
 import json
 import os
 import re
 import unicodedata
 from collections import OrderedDict
 from PyQt5.QtWidgets import (QMainWindow, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
                              QStackedWidget, QFormLayout, QScrollArea, QGroupBox, QComboBox,
                              QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, QCheckBox,
                              QDateEdit, QRadioButton, QButtonGroup, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem)
 from PyQt5.QtCore import QDate, QDateTime, Qt, QTimer
 from fpdf import FPDF  # Asegúrese de tener fpdf instalado (pip install fpdf)
 
 LAB_TITLE = "Laboratorio P.S. Iñapari - 002789"
 
 REGISTRY_ABBREVIATIONS = {
     "hematocrito": "Hto",
     "hematocrito (hto)": "Hto",
     "hemoglobina": "Hb",
     "hemoglobina (hb)": "Hb",
+    "hemoglobina - hematocrito": "Hb/Hto",
+    "hemoglobina hematocrito": "Hb/Hto",
     "leucocitos": "Leu",
     "leucocitos totales": "Leu",
     "recuento de leucocitos": "Leu",
     "recuento de hematies": "RBC",
     "recuento de hematies (rbc)": "RBC",
     "hematies": "RBC",
     "plaquetas": "Plaq",
     "recuento de plaquetas": "Plaq",
     "plaquetas totales": "Plaq",
     "vcm": "VCM",
     "hcm": "HCM",
     "chcm": "CHCM",
     "rdw": "RDW",
     "segmentados": "Seg",
     "abastonados": "Abast",
     "linfocitos": "Lin",
     "monocitos": "Mon",
     "eosinofilos": "Eo",
     "eosinofilos": "Eo",
     "basofilos": "Bas",
     "mielocitos": "Mielo",
     "metamielocitos": "Meta",
     "otras anormalidades": "Otras",
     "observaciones microscopicas": "Obs mic",
     "observaciones": "Obs",
diff --git a/main_window.py b/main_window.py
index 727968e063294b4dcf0ab2f5b3b35893b6ab4e69..1f5c34682cab2af09e8a011fb06420e714ee6155 100644
--- a/main_window.py
+++ b/main_window.py
@@ -932,50 +934,92 @@ def build_hematocrit_template(include_auto_hemoglobin=False):
     if include_auto_hemoglobin:
         hb_reference = SIMPLE_NUMERIC_TESTS.get("Hemoglobina", {}).get("reference")
         fields.append(
             {
                 "key": "hemoglobina",
                 "label": "Hemoglobina (estimada)",
                 "unit": "g/dL",
                 "reference": hb_reference,
                 "placeholder": "Calculada automáticamente"
             }
         )
         template["auto_calculations"] = [
             {
                 "source": "hematocrito",
                 "target": "hemoglobina",
                 "operation": "divide",
                 "operand": 3.03,
                 "decimals": 2,
                 "description": "Hb estimada = Hto / 3.03 (solo cuando se solicita Hematocrito)",
                 "clear_on_invalid": True
             }
         ]
     template["fields"] = fields
     return template
 
+
+def build_hemoglobin_hematocrit_combo_template():
+    template = build_hematocrit_template(include_auto_hemoglobin=True)
+    fields = template.get("fields", [])
+    hb_info = SIMPLE_NUMERIC_TESTS.get("Hemoglobina", {})
+    hematocrit_field = None
+    hemoglobin_field = None
+    for field in fields:
+        if field.get("key") == "hematocrito":
+            hematocrit_field = field
+        elif field.get("key") == "hemoglobina":
+            hemoglobin_field = field
+    if hemoglobin_field:
+        hb_label = hb_info.get("label", "Hemoglobina")
+        if "hb" not in hb_label.lower():
+            hb_label = f"{hb_label} (Hb)"
+        hemoglobin_field["label"] = hb_label
+        placeholder = hb_info.get("placeholder") or "Ej. 13.8"
+        hemoglobin_field["placeholder"] = placeholder
+        helper_text = hb_info.get("helper")
+        if helper_text:
+            hemoglobin_field["helper"] = helper_text
+    ordered_fields = []
+    if hemoglobin_field:
+        ordered_fields.append(hemoglobin_field)
+    if hematocrit_field:
+        ordered_fields.append(hematocrit_field)
+    if ordered_fields:
+        template["fields"] = ordered_fields
+    for calc in template.get("auto_calculations", []):
+        calc["only_if_empty"] = True
+        description = calc.get("description")
+        if description:
+            if "ajust" not in description.lower():
+                calc["description"] = f"{description} (se puede ajustar manualmente)"
+        else:
+            calc["description"] = "Hb estimada = Hto / 3.03 (se puede ajustar manualmente)"
+    return template
+
+
+TEST_TEMPLATES["Hemoglobina - Hematocrito"] = build_hemoglobin_hematocrit_combo_template()
+
 RAPID_TEST_NAMES = [
     "BHCG (Prueba de embarazo en sangre)",
     "VIH (Prueba rápida)",
     "Sífilis (Prueba rápida)",
     "VIH/Sífilis (Prueba combinada)",
     "Hepatitis A (Prueba rápida)",
     "Hepatitis B (Prueba rápida)",
     "PSA (Prueba rápida)",
     "Sangre oculta en heces (Prueba rápida)",
     "Helicobacter pylori (Prueba rápida)",
     "Covid-19 (Prueba antigénica)",
     "Covid-19 (Prueba serológica)",
     "Dengue NS1/IgM/IgG (Prueba rápida)"
 ]
 
 for rapid_test in RAPID_TEST_NAMES:
     if rapid_test not in TEST_TEMPLATES:
         TEST_TEMPLATES[rapid_test] = build_bool_observation_template()
 
 
 
 class AddTestsDialog(QDialog):
     def __init__(self, tests, disabled_tests=None, parent=None):
         super().__init__(parent)
         self.setWindowTitle("Agregar pruebas a la orden")
diff --git a/main_window.py b/main_window.py
index 727968e063294b4dcf0ab2f5b3b35893b6ab4e69..1f5c34682cab2af09e8a011fb06420e714ee6155 100644
--- a/main_window.py
+++ b/main_window.py
@@ -2109,64 +2153,94 @@ class MainWindow(QMainWindow):
                 return []
         elif self._is_blank_result(text_value):
             return []
         return [f"{test_name}: {text_value}"]
     def _format_result_for_export(self, test_name, raw_result, context=None):
         lines = self._format_result_lines(test_name, raw_result, context=context)
         if not lines:
             return ""
         if len(lines) <= 1:
             line = lines[0]
             parts = line.split(": ", 1)
             return parts[1] if len(parts) > 1 else line
         cleaned = []
         for line in lines[1:]:
             stripped = line.strip()
             if stripped.endswith(":") and "•" not in stripped:
                 continue
             cleaned.append(stripped.replace("• ", ""))
         return " | ".join(cleaned)
 
     def _build_registry_summary(self, test_name, raw_result, context=None):
         sections = self._collect_registry_sections(test_name, raw_result, context=context)
         if not sections:
             return []
         lines = []
-        for pairs in sections:
+        for section_idx, pairs in enumerate(sections):
             processed_pairs = self._post_process_registry_pairs(pairs)
+            if not processed_pairs:
+                continue
+            first_entry = processed_pairs[0]
+            if first_entry.get("key") == "resultado":
+                result_value = first_entry.get("value")
+                if result_value:
+                    lines.append(f"{test_name}: {result_value}")
+                for extra in processed_pairs[1:]:
+                    extra_value = extra.get("value")
+                    if not extra_value:
+                        continue
+                    label = extra.get("label", "")
+                    if label:
+                        lines.append(f"{label}: {extra_value}")
+                    else:
+                        lines.append(str(extra_value))
+                continue
             parts = []
             for entry in processed_pairs:
                 label = entry.get("label", "")
                 value = entry.get("value", "")
                 if not value:
                     continue
                 if label:
                     parts.append(f"{label}: {value}")
                 else:
                     parts.append(str(value))
             if parts:
-                lines.append(", ".join(parts))
+                line_text = ", ".join(parts)
+                if section_idx == 0 and test_name:
+                    normalized_line = self._normalize_text(line_text)
+                    normalized_test = self._normalize_text(test_name)
+                    expected_label = self._abbreviate_registry_label(test_name)
+                    normalized_expected = self._normalize_text(expected_label) if expected_label else ""
+                    include_name = True
+                    if normalized_test and normalized_test in normalized_line:
+                        include_name = False
+                    elif normalized_expected and normalized_expected in normalized_line:
+                        include_name = False
+                    if include_name:
+                        line_text = f"{test_name}: {line_text}"
+                lines.append(line_text)
         return lines
 
     def _collect_registry_sections(self, test_name, raw_result, context=None):
         parsed = self._parse_stored_result(raw_result)
         template_key = parsed.get("template") if isinstance(parsed, dict) else None
         template = TEST_TEMPLATES.get(template_key) if template_key in TEST_TEMPLATES else TEST_TEMPLATES.get(test_name)
         if parsed.get("type") == "structured" and template:
             values = parsed.get("values", {})
             sections = []
             current_section = []
             for field_def in template.get("fields", []):
                 if field_def.get("type") == "section":
                     if current_section:
                         sections.append(current_section)
                         current_section = []
                     continue
                 key = field_def.get("key")
                 if not key:
                     continue
                 value = values.get(key, "")
                 normalized_value = self._normalize_registry_value(value)
                 if normalized_value is None:
                     continue
                 label = field_def.get("label", key)
                 short_label = self._abbreviate_registry_label(label, key)
diff --git a/main_window.py b/main_window.py
index 727968e063294b4dcf0ab2f5b3b35893b6ab4e69..1f5c34682cab2af09e8a011fb06420e714ee6155 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3418,127 +3492,147 @@ class MainWindow(QMainWindow):
             "registro.pdf",
             "Archivos PDF (*.pdf)"
         )
         if not file_path:
             return
         if not file_path.lower().endswith(".pdf"):
             file_path += ".pdf"
         pdf = FPDF('L', 'mm', 'A4')
         pdf.set_margins(12, 12, 12)
         pdf.set_auto_page_break(True, margin=14)
         pdf.add_page()
         pdf.set_font("Arial", 'B', 12)
         pdf.cell(0, 8, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
         pdf.set_font("Arial", '', 9)
         pdf.cell(0, 6, self._ensure_latin1(f"Registro de resultados - {description}"), ln=1, align='C')
         pdf.ln(2)
         headers = [
             "Fecha",
             "Datos del paciente (Apellidos y nombres / Documento / F. Nac. / HCL)",
             "Hematología",
             "Bioquímica",
             "Microbiología y Parasitología",
             "Otros exámenes / Observaciones"
         ]
         column_widths = [24, 74, 50, 45, 45, 35]
-        pdf.set_fill_color(220, 220, 220)
-        pdf.set_font("Arial", 'B', 7.8)
-        for header, width in zip(headers, column_widths):
-            pdf.cell(width, 6, self._ensure_latin1(header), border=1, align='C', fill=True)
-        pdf.ln(6)
-
-        def ensure_space(required_height):
-            if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
-                pdf.add_page()
-                pdf.set_font("Arial", 'B', 12)
-                pdf.cell(0, 8, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
-                pdf.set_font("Arial", '', 9)
-                pdf.cell(0, 6, self._ensure_latin1(f"Registro de resultados - {description}"), ln=1, align='C')
-                pdf.ln(2)
-                pdf.set_fill_color(220, 220, 220)
-                pdf.set_font("Arial", 'B', 7.8)
-                for header, width in zip(headers, column_widths):
-                    pdf.cell(width, 6, self._ensure_latin1(header), border=1, align='C', fill=True)
-                pdf.ln(6)
-                pdf.set_font("Arial", '', 6.4)
+        line_height = 3.0
+        padding_x = 1.2
+        padding_y = 0.8
 
         def wrap_cell_text(text, available_width):
             sanitized = self._ensure_latin1(str(text) if text not in (None, "") else "-")
             segments = []
             for part in sanitized.split('\n'):
                 part = part.strip()
                 if part:
                     segments.append(part)
             if not segments:
                 segments = [sanitized.strip() or "-"]
             lines = []
             for segment in segments:
                 words = segment.split()
                 if not words:
                     lines.append("-")
                     continue
                 current = words[0]
                 for word in words[1:]:
                     candidate = f"{current} {word}"
                     if pdf.get_string_width(candidate) <= max(available_width, 1):
                         current = candidate
                     else:
                         lines.append(current)
                         current = word
                 lines.append(current)
             return lines or ["-"]
 
+        def draw_header():
+            pdf.set_fill_color(220, 220, 220)
+            pdf.set_font("Arial", 'B', 7.8)
+            cell_lines = []
+            max_lines = 1
+            for idx, header in enumerate(headers):
+                available = max(column_widths[idx] - 2 * padding_x, 1)
+                lines = wrap_cell_text(header, available)
+                cell_lines.append(lines)
+                if len(lines) > max_lines:
+                    max_lines = len(lines)
+            row_height = max_lines * line_height + 2 * padding_y
+            x_start = pdf.l_margin
+            y_start = pdf.get_y()
+            pdf.set_draw_color(180, 180, 180)
+            pdf.set_line_width(0.25)
+            for idx, lines in enumerate(cell_lines):
+                cell_width = column_widths[idx]
+                x_pos = x_start + sum(column_widths[:idx])
+                pdf.rect(x_pos, y_start, cell_width, row_height, style='DF')
+                text_y = y_start + padding_y
+                for line in lines:
+                    pdf.set_xy(x_pos + padding_x, text_y)
+                    pdf.cell(cell_width - 2 * padding_x, line_height, line, border=0, align='C')
+                    text_y += line_height
+            pdf.set_xy(pdf.l_margin, y_start + row_height)
+            pdf.set_font("Arial", '', 6.4)
+
+        def ensure_space(required_height):
+            if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
+                pdf.add_page()
+                pdf.set_font("Arial", 'B', 12)
+                pdf.cell(0, 8, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
+                pdf.set_font("Arial", '', 9)
+                pdf.cell(0, 6, self._ensure_latin1(f"Registro de resultados - {description}"), ln=1, align='C')
+                pdf.ln(2)
+                draw_header()
+                return True
+            return False
+
         def render_row(texts):
-            line_height = 3.0
-            padding_x = 1.2
-            padding_y = 0.8
             cell_lines = []
             max_lines = 1
             for idx, text in enumerate(texts):
                 available = max(column_widths[idx] - 2 * padding_x, 1)
                 lines = wrap_cell_text(text, available)
                 cell_lines.append(lines)
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             row_height = max_lines * line_height + 2 * padding_y
             ensure_space(row_height)
             x_start = pdf.l_margin
             y_start = pdf.get_y()
             pdf.set_draw_color(210, 215, 226)
             pdf.set_line_width(0.2)
             for idx, lines in enumerate(cell_lines):
                 cell_width = column_widths[idx]
                 x_pos = x_start + sum(column_widths[:idx])
                 pdf.rect(x_pos, y_start, cell_width, row_height)
                 text_y = y_start + padding_y
                 for line in lines:
                     pdf.set_xy(x_pos + padding_x, text_y)
                     pdf.cell(cell_width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
             pdf.set_xy(pdf.l_margin, y_start + row_height)
 
-        pdf.set_font("Arial", '', 6.4)
+        draw_header()
 
         def group_text(entry, key):
             values = entry.get("groups", {}).get(key, [])
             cleaned = [" ".join(str(val).split()) for val in values if str(val).strip()]
             return "\n".join(cleaned) if cleaned else "-"
 
         for entry in aggregated:
             ordered_cells = [
                 self._format_date_for_registry(entry),
                 self._format_patient_block_for_registry(entry),
                 group_text(entry, "hematology"),
                 group_text(entry, "biochemistry"),
                 group_text(entry, "micro_parasito"),
                 group_text(entry, "others")
             ]
             render_row(ordered_cells)
         try:
             pdf.output(file_path)
         except Exception as exc:
             QMessageBox.warning(self, "Error", f"No se pudo generar el PDF:\n{exc}")
             return
         QMessageBox.information(self, "Exportado", f"Registro guardado en:\n{file_path}")
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
