diff --git a/main_window.py b/main_window.py
index 1f5c34682cab2af09e8a011fb06420e714ee6155..66fb15088584ac2b3d622b4933225ba614147d82 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1970,82 +1970,104 @@ class MainWindow(QMainWindow):
         target_info = field_entries.get(target_key)
         if not source_info or not target_info:
             return
         if source_info.get("type") not in ("line",):
             return
         if target_info.get("type") not in ("line",):
             return
         source_widget = source_info.get("widget")
         target_widget = target_info.get("widget")
         if not source_widget or not target_widget:
             return
         operation = calc.get("operation")
         operand = calc.get("operand")
         decimals = calc.get("decimals", 2)
         only_if_empty = calc.get("only_if_empty", False)
         apply_on_load = calc.get("apply_on_load", True)
         description = calc.get("description")
         if description and not target_info.get("has_auto_helper"):
             container = target_info.get("container")
             if container and container.layout():
                 helper_label = QLabel(description)
                 helper_label.setWordWrap(True)
                 helper_label.setStyleSheet("color: #0a84ff; font-size: 10px;")
                 container.layout().addWidget(helper_label)
                 target_info["has_auto_helper"] = True
+        auto_state = target_info.setdefault("_auto_calc_state", {
+            "manual_override": False,
+            "last_auto_value": "",
+            "listener_connected": False
+        })
+
+        def _handle_target_edit(text):
+            stripped = text.strip()
+            if stripped:
+                auto_state["manual_override"] = True
+            else:
+                auto_state["manual_override"] = False
+                auto_state["last_auto_value"] = ""
+
+        if not auto_state.get("listener_connected"):
+            target_widget.textEdited.connect(_handle_target_edit)
+            auto_state["listener_connected"] = True
         def on_change(text):
             value = self._to_float(text)
             if value is None:
                 if calc.get("clear_on_invalid", False):
                     target_widget.blockSignals(True)
                     target_widget.clear()
                     target_widget.blockSignals(False)
+                    auto_state["last_auto_value"] = ""
+                    auto_state["manual_override"] = False
                 return
             result = None
             if operation == "divide":
                 if operand in (0, None):
                     return
                 result = value / operand
             elif operation == "multiply" and operand is not None:
                 result = value * operand
             elif operation == "add" and operand is not None:
                 result = value + operand
             elif operation == "subtract" and operand is not None:
                 result = value - operand
             if result is None:
                 return
-            if only_if_empty and target_widget.text().strip():
+            current_text = target_widget.text().strip()
+            if only_if_empty and auto_state.get("manual_override") and current_text:
                 return
             if target_widget.hasFocus() and not calc.get("update_while_editing", False):
                 return
             if decimals is not None:
                 formatted = f"{result:.{decimals}f}".rstrip('0').rstrip('.')
             else:
                 formatted = str(result)
             target_widget.blockSignals(True)
             target_widget.setText(formatted)
             target_widget.blockSignals(False)
+            auto_state["last_auto_value"] = formatted
+            auto_state["manual_override"] = False
         source_widget.textChanged.connect(on_change)
         if apply_on_load:
             on_change(source_widget.text())
     def _structured_dict_to_text(self, values):
         if not isinstance(values, dict):
             return ""
         parts = []
         for key, val in values.items():
             if val:
                 parts.append(f"{key}: {val}")
         return "; ".join(parts)
     def _parse_stored_result(self, raw_result):
         if isinstance(raw_result, dict):
             return raw_result
         if raw_result in (None, ""):
             return {"type": "text", "value": ""}
         try:
             data = json.loads(raw_result)
         except (TypeError, json.JSONDecodeError):
             return {"type": "text", "value": raw_result}
         if isinstance(data, dict) and data.get("type") == "structured":
             return data
         return {"type": "text", "value": raw_result if raw_result is not None else ""}
     def _get_widget_value(self, field_info):
         if not field_info:
